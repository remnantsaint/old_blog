<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-04T08:15:49.295Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github使用指南</title>
    <link href="http://example.com/2023/06/20/Github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2023/06/20/Github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2023-06-19T23:51:51.000Z</published>
    <updated>2023-07-04T08:15:49.295Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建github账号记住github用户名-邮箱-密码略"><a class="markdownIt-Anchor" href="#创建github账号记住github用户名-邮箱-密码略"></a> 创建Github账号，记住Github用户名、邮箱、密码（略）</h4><h4 id="下载安装git略"><a class="markdownIt-Anchor" href="#下载安装git略"></a> 下载安装Git（略）</h4><h4 id="配置git"><a class="markdownIt-Anchor" href="#配置git"></a> 配置Git</h4><p>打开git bash（可以在开始界面找到，或者在文件夹空白处右键选择打开git bash），接下来的命令都在git bash内完成</p><p>连接Github：<br /><code>git config --global user.name &quot;你的Github用户名&quot;</code><br /><code>git config --global user.email &quot;你的Github邮箱&quot;</code></p><p>创建密匙，来让本机能绑定访问Github，能在你的Github上传文件：<br /><code>ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</code></p><p>添加公钥：<br />在Github网页端，头像——&gt;Settings——&gt;SSH and GPG keys——&gt;New SSH key<br />Title随便写，Key处要找到你刚才创建的密匙文件，一般在：C盘——&gt;用户——&gt;用户名——&gt;.ssh文件夹，打开id_rsa.pub文件，将内容复制到Key处</p><p>验证连接：`ssh -T <a href="mailto:git@github.com">git@github.com</a>&quot;</p><h4 id="使用git"><a class="markdownIt-Anchor" href="#使用git"></a> 使用Git</h4><p>参考链接：<a href="https://www.remsait.com/2023/04/18/git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">Git基础教程 | Remsait</a></p><h4 id="github网页端的使用"><a class="markdownIt-Anchor" href="#github网页端的使用"></a> Github网页端的使用</h4><p>（1）在别人的项目处，右上角找到fork，就能克隆一个他人的仓库到自己的仓库<br />（2）在本地的dev分支用git提交完修改后，能看到自己网页端的dev分支已经变化，一般会弹出一个绿色的合并按钮，点击然后检查后就能合并到主分支<br />（3）将自己fork后的参仓库的修改提交，申请主仓库合并</p><h4 id="20236-用github和自己的域名创建多个网站"><a class="markdownIt-Anchor" href="#20236-用github和自己的域名创建多个网站"></a> 2023.6 用Github和自己的域名创建多个网站</h4><p>仅记录我的做法：<br />我的域名在腾讯云解析，添加一个主机记录为acg，记录类型为A</p><p>在Github上创建一个仓库，进入仓库设置，点击Pages，将Branch设置为main分支，将Custom domain设置为新的域名，例如我的<code>acg.remsait.com</code></p><p>然后等待一会，浏览器输入<code>acg.remsait.com</code>就能显示index.html指向的网页了。</p><h4 id="同步提交gitee和github仓库"><a class="markdownIt-Anchor" href="#同步提交gitee和github仓库"></a> 同步提交gitee和github仓库</h4><p>首先保证两个平台都有本地电脑的公钥，在.git文件夹的config文件的remote中添加url指向新的仓库，然后暴力推送一次同步<code>\^o^/</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;创建github账号记住github用户名-邮箱-密码略&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#创建github账号记住github用户名-邮箱-密码略&quot;&gt;&lt;/a&gt; 创建Github账号，记住Github用户名、邮箱、密码（略）</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>DFS（图论）</title>
    <link href="http://example.com/2023/05/09/DFS%EF%BC%88%E5%9B%BE%E8%AE%BA%EF%BC%89/"/>
    <id>http://example.com/2023/05/09/DFS%EF%BC%88%E5%9B%BE%E8%AE%BA%EF%BC%89/</id>
    <published>2023-05-09T14:19:58.000Z</published>
    <updated>2023-05-19T10:52:14.927Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引入"><a class="markdownIt-Anchor" href="#引入"></a> 引入</h4><p>DFS全称是<a href="https://en.wikipedia.org/wiki/Depth-first_search">Depth First Search</a>，中文名是深度优先搜索，是一种用于遍历或搜索树或图的算法。深度优先就是每次都尝试向更深的节点走。</p><p>该算法和常与BFS并列，但两者除了都能遍历图的连通块意外，用途完全不同，很少能混用两种算法</p><p>DFS常常用来代指用递归函数实现的搜索，但实际上两者并不一样，有关参考<a href="https://www.remsait.com/2023/04/11/DFS-%E6%90%9C%E7%B4%A2/">DFS(搜索)</a></p><h4 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h4><p>DFS 最显著的特征在于其<strong>递归调用自身</strong>。同时与BFS类似，DFS会对其访问过的点打上标记，在遍历图时跳过已打标记的点，以确保<strong>每个点仅访问一次</strong>，符合以上两点便是广义上的DFS</p><p>具体地说，DFS大致结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">//只包含DFS必须的主要结构，实际的DFS会在以上代码基础上加入一些代码，利用DFS性质进行其它操作<br>DFS(v) // v 可以是图中的一个顶点，也可以是抽象的概念，如 dp 状态等。<br>  在 v 上打访问标记<br>  <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> v 的相邻节点<br>    <span class="hljs-keyword">if</span> u 没有打过访问标记 then<br>      DFS(u)<br>    end<br>  end<br>end<br><br></code></pre></td></tr></table></figure><h4 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质</h4><p>该算法通常的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>表示点数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>表示边数。</p><p>参考：<a href="https://oi.wiki">OI.wiki</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;引入&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引入&quot;&gt;&lt;/a&gt; 引入&lt;/h4&gt;
&lt;p&gt;DFS全称是&lt;a href=&quot;https://en.wikipedia.org/wiki/Depth-first_search&quot;&gt;Depth F</summary>
      
    
    
    
    <category term="图论" scheme="http://example.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>图的存储</title>
    <link href="http://example.com/2023/05/07/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <id>http://example.com/2023/05/07/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/</id>
    <published>2023-05-07T09:25:32.000Z</published>
    <updated>2023-05-09T14:15:41.190Z</updated>
    
    <content type="html"><![CDATA[<p>想要对图进行操作，就得先学习图的存储方式。</p><p>本文中用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>代指图的点数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>代指图的边数（注意，点的标号不会超过n）</p><h3 id="直接存边"><a class="markdownIt-Anchor" href="#直接存边"></a> 直接存边</h3><p>使用一个数组来存边，数组中每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或使用多个数组分别存起点、终点和边权）</p><p>复杂度：<br />查询是否存在某条边：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><br />遍历一个点的所有出边：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><br />遍历整张图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><br />空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>应用：<br />由于直接存边的遍历效率低下，一般用于遍历图</p><p>在<a href="">Kruskal</a>算法中，由于需要将边按边权排序，故需要直接存边</p><p>在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，需要重建图时利用直接存下的边来建图</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>  <span class="hljs-type">int</span> u, v;<br>&#125;;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;Edge&gt; e;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br><br><span class="hljs-comment">//找是否存在从u到v的边</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (e[i].u == u &amp;&amp; e[i].v == v) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//从u开始遍历能到达的边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>  vis[u] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (e[i].u == u) &#123;<br>      <span class="hljs-built_in">dfs</span>(e[i].v);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<span class="hljs-comment">//n结点，m条边</span><br><br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//resize()调整容器大小</span><br>  e.<span class="hljs-built_in">resize</span>(m + <span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v;<br>  <span class="hljs-comment">//起点u,终点v</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h3><p>使用一个二位数组<code>adj</code>来存边，其中<code>adj[u][v]</code>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时表示存在从u到v的边，为0表示不存在。如果是带边权的图，可以在<code>adj[u][v]</code>中存储u到v的边的边权</p><p>复杂度：<br />查询是否存在某条边：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><br />遍历一个边的所有出边：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br />遍历整张图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br />空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>应用：<br />邻接矩阵只适用于没有重边（或重边可忽略）的情况</p><p>其最显著的优点是可以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>查询一条边是否存在</p><p>由于邻接矩阵在稀疏图上的效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; adj;<br><br><span class="hljs-comment">//找边</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123; <span class="hljs-keyword">return</span> adj[u][v]; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>  vis[u] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) &#123;<br>    <span class="hljs-keyword">if</span> (adj[u][v]) &#123;<br>      <span class="hljs-built_in">dfs</span>(v);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br><br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> u, v;<br>    cin &gt;&gt; u &gt;&gt; v;<br>    adj[u][v] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h3><p>使用一个支持动态增加元素的数据结构构成的数组，如<code>vector&lt;int&gt; adj[n+1]</code>来存边，其中<code>adj[u]</code>存储的是点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>的所有出边的相关信息（终点、边权等）</p><p>复杂度：<br />查询是否存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的边：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>d</mi><mo>+</mo></msup><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d^+(u))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>（如果事先进行了排序就可以使用<a href="">二分查找</a>做到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msup><mi>d</mi><mo>+</mo></msup><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(d^+(u)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>)</p><p>遍历点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>的所有出边：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>d</mi><mo>+</mo></msup><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d^+(u))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p><p>遍历整张图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>应用：<br />存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）。</p><p>尤其适用于需要对一个点的所有出边进行排序的场合</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; adj;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[u].<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">if</span> (adj[u][i] == v) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>  vis[u] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[u].<span class="hljs-built_in">size</span>(); ++i) <span class="hljs-built_in">dfs</span>(adj[u][i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br><br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  adj.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> u, v;<br>    cin &gt;&gt; u &gt;&gt; v;<br>    adj[u].<span class="hljs-built_in">push_back</span>(v);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="链接前向星"><a class="markdownIt-Anchor" href="#链接前向星"></a> 链接前向星</h3><p>本质上是用链表实现的邻接表，核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head[u]和cnt的初始值都为-1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span> <span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>cnt++;<br>nxt[cnt] = head[u];<br>head[u] = cnt;<br>to[cnt] = v;<br>&#125;<br><br><span class="hljs-comment">//遍历u的出边</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = nxt[i])&#123;<br><span class="hljs-type">int</span> v = to[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：<br />查询是否存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的边：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>d</mi><mo>+</mo></msup><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d^+(u))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>遍历点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>的所有出边：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>d</mi><mo>+</mo></msup><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d^+(u))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>遍历整张图：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><p>应用：<br />存各种图都很适合，但不能快速查询一条边是否存在，也不能方便地对一个点的出边进行排序</p><p>优点是边是带变编号的，有时会非常有用，而且如果<code>cnt</code>的初始值是奇数，存双向边时<code>i^i</code>即是<code>i</code>的反边（常用于网络流）</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>vector&lt;<span class="hljs-type">int</span>&gt; head, nxt, to;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  nxt.<span class="hljs-built_in">push_back</span>(head[u]);<br>  head[u] = to.<span class="hljs-built_in">size</span>();<br>  to.<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = nxt[i]) &#123;  <span class="hljs-comment">// ~i 表示 i != -1</span><br>    <span class="hljs-keyword">if</span> (to[i] == v) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>  vis[u] = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = nxt[i]) <span class="hljs-built_in">dfs</span>(to[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m;<br><br>  vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  head.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> u, v;<br>    cin &gt;&gt; u &gt;&gt; v;<br>    <span class="hljs-built_in">add</span>(u, v);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<a href="https://oi.wiki">https://oi.wiki</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想要对图进行操作，就得先学习图的存储方式。&lt;/p&gt;
&lt;p&gt;本文中用&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semanti</summary>
      
    
    
    
    <category term="图论" scheme="http://example.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>linux一些命令</title>
    <link href="http://example.com/2023/05/02/linux%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2023/05/02/linux%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</id>
    <published>2023-05-02T03:09:33.000Z</published>
    <updated>2023-11-01T09:47:19.499Z</updated>
    
    <content type="html"><![CDATA[<p><code>du -sh</code>查看文件夹大小；<code>du -sh *</code>查看该文件夹下每个文件或文件夹的大小</p><p><code>systemctl start &lt;service&gt;</code>开启服务<br /><code>systemctl enable &lt;service&gt;</code>服务开机自启动<br /><code>systemctl restert &lt;service&gt;</code>重启服务<br /><code>systemctl list-unit-files</code>查看服务列表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;du -sh&lt;/code&gt;查看文件夹大小；&lt;code&gt;du -sh *&lt;/code&gt;查看该文件夹下每个文件或文件夹的大小&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl start &amp;lt;service&amp;gt;&lt;/code&gt;开启服务&lt;br /&gt;
&lt;code&gt;sy</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Git基础教程</title>
    <link href="http://example.com/2023/04/18/git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2023/04/18/git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</id>
    <published>2023-04-18T11:12:39.000Z</published>
    <updated>2023-06-30T02:15:55.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git命令简易汇总"><a class="markdownIt-Anchor" href="#git命令简易汇总"></a> Git命令简易汇总</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">初始化</span><br>git init<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">添加到暂存区</span><br>git add &lt;filename&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">提交文件</span><br>git commit -m &quot;&lt;commit descriptrion&gt;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看文件修改</span><br>git diff &lt;filename&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看暂存区和工作区状态</span><br>git status<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看历史提交/快照</span><br>git log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看历史命令</span><br>git relog<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">回退到某一版本</span><br>git reset --hard &lt;commit_id&gt;/&lt;HEAD^&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">比较工作区与版本库最新文件的区别</span><br>git diff HEAD -- &lt;filename&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">撤销文件还未添加的修改（丢弃工作区的修改）</span><br>git checkout -- &lt;filename&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">把上次添加进入暂存区修改的撤销掉，重新加入暂存区（丢弃暂存区的修改）</span><br>git reset HEAD &lt;file&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除版本库中文件</span><br>git rm &lt;filename&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">连接远程库</span><br>git remote add origin git@github.com:&lt;username&gt;/&lt;repositoriyname&gt;.git<br>git remote add origin git@gitee.com:&lt;username&gt;/&lt;repositoryname&gt;.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将本地库推送到远程库(分支名可选，只有第一次需要 -u，可加--force强制推送)</span><br>git push -u origin main<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">抓取分支</span><br>git pull<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建并抓取dev分支</span><br>git checkout -v dev origin/dev<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看远程库信息</span><br>git remote -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">切断与远程库的连接</span><br>git remote rm &lt;name&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将远程库克隆到本地</span><br>git clone git@github.com:&lt;githubname&gt;/&lt;repositoryname&gt;.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建分支</span><br>git branch &lt;branchname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">切换分支</span><br>git checkout &lt;branchname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建并切换分支</span><br>git switch -c &lt;branchname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看当前分支</span><br>git branch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">合并某分支</span><br>git merge &lt;branchname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">禁用Fast forward模式来合并分支</span><br>git merge --no-ff -m &quot;description&quot; &lt;branchname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除某分支</span><br>git branch -d &lt;branchname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">更改分支名称</span><br>git branch -m master main<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">分支合并图</span><br>git log --graph<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置本地dev和远程dev分支的链接</span><br>git branch --set-upstream-to=origin/dev dev<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">打标签</span><br>git tag -a &lt;name&gt; -m &lt;description&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看所有标签</span><br>git tag<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看标签信息</span><br>git show &lt;tagname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">推送本地标签</span><br>git push origin &lt;tagname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">推送全部未推送过的本地标签</span><br>git push origin --tags<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除标签</span><br>git tag -d &lt;tagname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">远程删除标签</span><br>git push origin :refs/tags/&lt;tagname&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">解决警告</span><br>git config --global core.autocrlf true<br><br>git pull --allow-unrelated-histories<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">暴力推送直接覆盖，不管拉没拉取</span><br>git push -f<br></code></pre></td></tr></table></figure><h3 id="git简介"><a class="markdownIt-Anchor" href="#git简介"></a> Git简介</h3><p>Git是目前世界上最先进的分布式版本控制系统，能自动记录每次文件的改动</p><p>CVS和SVN都是集中式的版本控制系统，版本库集中存放在中央服务器，最大的毛病是必须联网才能工作。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑都是一个完整的版本库，使用git不需要联网。分布式控制系统安全性更高，因为一个电脑坏掉后，可以复制其他人的版本库</p><h3 id="安装git"><a class="markdownIt-Anchor" href="#安装git"></a> 安装Git</h3><p>1.在Linux上安装Git</p><p>若在Debian和Ubuntu上，直接用<code>sudo apt-get install git</code>就能安装，若在老版本的Debian和Ubuntu，用<code>sudo apt-get install git-core</code>下载</p><p>其它版本可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入<code>./config</code> <code>make</code> <code>sudo make install</code>即可</p><p>2.在Windows上安装Git</p><p>在官网下载安装程序，然后默认选项安装，有Git Bash就说明安装成功</p><p>安装完成后还需要最后一步配置，在命令行输入：<br /><code>$ git config --global user.name &quot;Your Name&quot;（GitHub用户名）</code><br /><code>$ git config --global user.email &quot;email@example.com&quot;（GitHub邮箱）</code><br />因为Git是分布式版本控制，所以，每个机器都必须自报家门：你的名字和Email地址。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址</p><h3 id="创建版本库"><a class="markdownIt-Anchor" href="#创建版本库"></a> 创建版本库</h3><p>版本库即repository，可以简单理解成一个目录，这个目录里所有的文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时候都可以追踪历史，或者在将来某个时刻可以还原。</p><p>所以，创建一个版本库非常简单，首先选择一个合适的地方，创建一个空目录，以下操作都在该目录中进行：<br /><code> $ mkdir learngit</code><br /><code> $ cd learngit</code><br />第二步，用<code>git init</code>命令把这个目录变成Git可以管理的仓库：<br /><code> $ git init</code><br />初始化后，目录下会多一个<code>.git</code>目录，默认隐藏，这个目录是来跟踪管理版本库的，不要改动。</p><p>所有的版本控制系统，只能跟踪文本文件的改动，比如在一个文件的第几行盖了什么。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。</p><p>强烈建议使用UTF-8编码来编写文件。使用windows需要注意千万不要使用Windows自带的记事本编辑任何文本文件，原因是Microsoft开发记事本的团队在每个文件开头添加了0x3fbbbf的字符，会导致错误</p><p>首先编写一个<code>readme.txt</code>文件，用<code>git add readme.txt</code>命令告诉Git将该文件添加到仓库，用<code>git commit -m &quot;wrote a readme file&quot;</code>告诉Git，把文件提交到仓库，<code>-m</code>后面输入的是本次提交的说明</p><h3 id="时光机穿梭"><a class="markdownIt-Anchor" href="#时光机穿梭"></a> 时光机穿梭</h3><p>我们已经成功添加并提交了一个readme.txt文件，现在，可以继续修改readme.txt文件，然后运行<code>git status</code>查看结果</p><p><code>git status</code>命令让我们时刻掌握仓库当前的状态，命令的输出告诉我们呢，<code>readme.txt</code>被改动过了，但还没有准备提交的修改</p><p>如果想查看怎么修改的<code>readme.txt</code>文件，可以使用<code>git diff</code>这个命令，结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff readme.txt</span> <br>diff --git a/readme.txt b/readme.txt<br>index 46d49bf..9247db6 100644<br>--- a/readme.txt<br>+++ b/readme.txt<br>@@ -1,2 +1,2 @@<br>-Git is a version control system.<br>+Git is a distributed version control system.<br> Git is free software.<br></code></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看different，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>文件作了什么修改后，再添加到仓库就会很放心，先添加<code>git add readme.txt</code>，然后用<code>git status</code>查看状态，会告诉我们添加的修改包括<code>readme.txt</code></p><p>下一步就可以放心提交<code>$ git commit -m &quot;add distributed&quot;</code>，提交后再用<code>git status</code>查看状态，会告诉我们当前没有需要提交的修改，而且工作目录是干净的</p><h4 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h4><p>现在已经学会了修改文件后提交到Git版本库，就像打游戏一样，每一次存档都相当于一次快照这个快照相当于<code>commit</code>，每次把文件改乱了，或误删了文件，可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是丢失成果。</p><p>在Git中，可以使用<code>git log</code>命令查看历史快照记录，若嫌输出信息太多，可以加上参数<code>git log --pretty=oneline</code>，每一个<code>commit id</code>都是独一无二的</p><p>要想回退版本，首先要知道在Git中，用<code>HEAD</code>表示当前版本，用<code>HEAD^</code>表示上一个版本，用<code>HEAD~10</code>表示上十个版本。接着用命令<code>git reset --hard HEAD^</code>回退到上一版本，这时若查看历史记录，会发现回退前的版本已经不见了，不过只要窗口还没有关掉，记录回退前版本的<code>commit id</code>，就可用命令<code>git reset --hard 1094a</code>来反回退，版本号没必要写全，Git会自动寻找版本。</p><p>Git的版本回退非常快，因为在Git内部使用了指向当前版本的<code>HEAD</code>指针，回退版本时，Git仅仅移动指针，然后顺便把工作区的文件更新。</p><p>若第二天回退后悔了，可以用<code>git reflog</code>命令查看使用过历史命令</p><h4 id="工作区和暂存区"><a class="markdownIt-Anchor" href="#工作区和暂存区"></a> 工作区和暂存区</h4><p>工作区（Working Directory）就是在电脑中能看到的目录，比如创建的gitlearn文件夹。</p><p>版本库（Repository），工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。Git的版本库存了很多东西，其中最重要的就是称为stage（或叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code></p><p>前面讲了，把文件往Git版本库添加的时候，是分<code>add</code>和<code>commit</code>两步执行的，<code>git add</code>实际就是把文件修改添加到暂存区，<code>git commit</code>实际就是把暂存区的所有内容提交到当前分支。因为创建Git版本库的时候，Git自动创建了唯一一个<code>master</code>分支，所以现在<code>git commit</code>就是往<code>master</code>分支提交更改</p><p>可以简单理解为，需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改。一旦将暂存区内容提交后，<code>git status</code>显示的暂存区就是干净的。</p><h4 id="管理修改"><a class="markdownIt-Anchor" href="#管理修改"></a> 管理修改</h4><p>Git比其他版本控制系统优秀的原因是：Git跟踪并管理的是修改，而非文件。</p><p>若先修改一次文件，然后<code>git add</code>添加，然后第二次修改，然后直接<code>git commit</code>提交，这时会发现第二次修改的进入暂存区内，也就是没有被提交，可用命令<code>git diff HEAD -- readme.txt</code>查看工作区和版本库里面最新版本的区别</p><p>那么，怎么提交第二次修改呢？先<code>git add</code>就行了</p><h4 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h4><p>若大意修改了文件但还没<code>add</code>，使用命令<code>git checkout -- &lt;filename&gt;</code>就能撤销所有修改，回到最近的一次<code>git add</code>时间的状态，即丢弃工作区的修改。</p><p>若修改已经放入了暂存区，但还没有提交，Git告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉。</p><p><code>git reset</code>既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本</p><p>小结：<br />（1）若乱改了某个文件内容，想丢弃工作区的修改，用命令<code>git checkout -- &lt;file&gt;</code><br />（2）若不但乱改了内容，还添加到了暂存区，想丢弃修改，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到场景一，第二部按场景一操作<code>git checkout -- &lt;file&gt;</code><br />（3）已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，前提是没有推送到远程仓库。</p><h4 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h4><p>在Git中，删除文件也是一个修改操作。当我们用<code>git add</code>提交后，一般情况下用<code>rm</code>来删除文件，这个时候本地的文件删除了，但版本库中还没删除该文件。</p><p>此时有两种选择：<br />（1）在版本库中，用<code>git rm &lt;filename&gt;</code>来删除文件，之后再<code>git commit -m &lt;description&gt;</code>即可<br />（2）删错了，版本库中还有该文件用<code>git checkout</code>即可一键还原</p><h3 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库"></a> 远程仓库</h3><p>Git是分布式版本控制系统，同一个Git仓库，可以分不到不同的机器上。最早只有一台机器有一个原始版本库，此后别的机器可以“克隆”这个机器的版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p><p>Github提供Git仓库托管服务，可以用作远程仓库，只需要一点设置</p><p>首先得创建私钥和公钥，在shell里输入<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>然后一路回车，会得到<code>id_rsa</code>和<code>id_rsa.pub</code>文件，前者是私钥，后者是公钥，将公钥添加到Github的key里即可。</p><p>Github可以添加多个KEY，假设你有若干电脑，一会在家提交，一会在公司提交，只要把每台电脑的KEY添加到Github即可</p><h4 id="添加远程库"><a class="markdownIt-Anchor" href="#添加远程库"></a> 添加远程库</h4><p>Github上的Git仓库，既可以作为备份，又可以让其他人通过该仓库来协作</p><p>首先创建一个名为<code>learngit</code>的仓库，然后再本地的<code>learngit</code>仓库中运行命令<code>git remote add origin git@github.com:&lt;username&gt;/&lt;repositoriyname&gt;.git</code>来连接远程库</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法。</p><p>下一步，将本地库的所有内容推送到远程库上：先将文件添加到本地库，然后用命令<code>git push -u origin main</code>推送到远程库。把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>main</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>main</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的main分支内容推送到远程新的<code>main</code>分支，还会把本地的<code>main</code>分支和远程的<code>main</code>分支关联起来，在以后的推送或者拉取时就可以简化命令，即<code>git push origin main</code></p><p>如果添加的时候地址写错了，可以先用<code>git remote -v</code>查看远程库信息，再用<code>git remote rm &lt;name&gt;</code>来删除远程库，其实就是切断与远程库的连接</p><p>分布式版本系统的最大好处之一是在本地工作不需要考虑联网，只要在有网络的时候推送一下就完成同步</p><h4 id="从远程库克隆"><a class="markdownIt-Anchor" href="#从远程库克隆"></a> 从远程库克隆</h4><p>用克隆命令：<code>git clone git@github.com:&lt;githubname&gt;/&lt;repositoryname&gt;.git</code>即可将远程库的文件克隆到本地</p><h3 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h3><p>Git可以创建分支，自己在自己的分支干活，想提交就提交，最后和主分支合并。这样会使过程更安全。</p><h4 id="创建和合并分支"><a class="markdownIt-Anchor" href="#创建和合并分支"></a> 创建和合并分支</h4><p>在版本回退中，每次提交，Git都会把它们串成一条时间线，这条时间线就是一个分支，这个分支叫主分支。</p><p>用命令<code>git branch &lt;branchname&gt;</code>来创建分支，<code>git checkout &lt;branchname&gt;</code>来切换分支，这两个命令可以结合成一个命令<code>git checkout -b &lt;branchname&gt;</code></p><p>用<code>git branch</code>查看分支，当前分支前会标一个<code>*</code>·。之后正常修改提交，再切换到主分支会发现文件并没有改动，因为提交后的dev指针在master指针前边，这时候可以选择将dev分支合并到master：<code>git merge &lt;branchname&gt;</code></p><p>合并完成后，可以用<code>git branch -d &lt;branchname&gt;</code>来删除分支</p><h4 id="解决冲突"><a class="markdownIt-Anchor" href="#解决冲突"></a> 解决冲突</h4><p>合并分支不会一帆风顺。当master分支和dev分支分别有各自新的提交，Git无法快速合并，只能试图把各自的修改合并起来，但是这种合并就可能发生冲突。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容再提交。用<code>git log --graph</code>命令可以看到分支合并图</p><h4 id="分支管理策略"><a class="markdownIt-Anchor" href="#分支管理策略"></a> 分支管理策略</h4><p>如果想要合并后保留分支信息，可以禁用<code>Fast forward</code>模式，Git就会在merge时产生一个新的commit，如命令<code>git merge --no-ff -m &quot;description&quot; &lt;branchname&gt;</code></p><p>实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先<code>master</code>分支应该是非常稳定，也就是仅用来发布新版本，平时不能在上面干活；</p><p>干活都在<code>dev</code>分支上，也就是说，工作完成后把<code>dev</code>分支合并到<code>master</code>分支上；所有人创自己的分支，然后合并到<code>dev</code>分支上就行了。</p><h4 id="多人协作"><a class="markdownIt-Anchor" href="#多人协作"></a> 多人协作</h4><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程<code>master</code>分支对应起来了，且远程仓库的默认名称是<code>origin</code>。</p><p>并不是一定要把本地分支往远程推送</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li><code>bug</code>分支只用于在本地修复bug，没必要推送到远程</li><li><code>feature</code>分支是否推送到远程，取决于你是否和你的小伙伴合作在上面开发</li></ul><h4 id="抓取分支"><a class="markdownIt-Anchor" href="#抓取分支"></a> 抓取分支</h4><p>如果只是用<code>git clone ~</code>命令把库克隆到本地，就只能看到<code>master</code>分支。如果想在<code>dev</code>分支上开发，那么必须创建远程<code>origin</code>的<code>dev</code>分支到本地，用命令<code>git checkout -v dev origin/dev</code>即可创建<code>dev</code>一样的分支。</p><p>如果你也修改了<code>dev</code>分支，那么提交的时候会提醒冲突，这时只要用<code>git pull</code>把最新的<code>dev</code>提交抓取下来在本地合并，就可以解决冲突。</p><p>如果<code>git pull</code>失败，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，设置<code>dev</code>和<code>origin/dev</code>的链接即可：<code>git branch --set-upstream-to=origin/dev dev</code></p><p><code>git pull</code>前注意要把本地库的修改提交一下，或者用<code>git checkout .</code>撤回修改</p><h3 id="标签管理"><a class="markdownIt-Anchor" href="#标签管理"></a> 标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样就唯一确定了打标签时刻的版本，所以标签也是版本库的一个快照。</p><p>标签可以代替<code>commit</code>号的那一长串数字，是一个有意义的名字</p><h4 id="创建标签"><a class="markdownIt-Anchor" href="#创建标签"></a> 创建标签</h4><p>在Git中打标签十分简单，首先用<code>git checkout &lt;branchname&gt;</code>切换到要打标签的分支。然后命令<code>git tag &lt;name&gt;</code>打标签即可。可用<code>git tag</code>查看所有标签。</p><p>默认标签是打在最新提交的commit上的，如果忘记打以前的标签，可以先用<code>git log --pretty=oneline --abbrev-commit</code>查看历史提交，然后用<code>git tag v1.4 f52c633</code>即可将f52c633的commit号打上标签v1.4</p><p>可用<code>git show &lt;tagname&gt;</code>查看标签信息。打标签时，可以加参数<code>-m</code>带有说明，<code>-a</code>指向标签名</p><h4 id="操作标签"><a class="markdownIt-Anchor" href="#操作标签"></a> 操作标签</h4><p>如果标签打错，可以删除：<code>git tag -d v0.1</code></p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>。或者一次性推送尚未推送到远程的本地标签：<code>git push origin --tags</code>。</p><p>如果标签已经推送到远程，想要删除标签，首先要从本地删除：<code>git tag -d v0.9</code>，然后从远程删除<code>git push origin :refs/tags/v0.9</code></p><h3 id="使用gitee"><a class="markdownIt-Anchor" href="#使用gitee"></a> 使用Gitee</h3><p>使用Github时，国内用户经常会访问太慢，就可以用国内的Gitee托管服务</p><p>和Github相比，Gitee也提供免费的Git仓库。使用Gitee和Github类似，都需要先绑定公钥。</p><p>创建一个和本地库名相同的远程库，用命令<code>git remote add origin git@gitee.com:&lt;username&gt;/&lt;repositoryname&gt;.git</code>将它和Gitee的远程库关联，之后就可以正常用<code>git push</code>和<code>git pull</code>推送了</p><p>若报错说已经关联一个名叫<code>origin</code>的远程库，可以用<code>git remote -v</code>查看远程库信息，然后删除与Github远程库的联系，再关联Gitee的远程库。也可以通过改远程库origin的名称来关联不同的远程库</p><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">廖雪峰Git教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git命令简易汇总&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#git命令简易汇总&quot;&gt;&lt;/a&gt; Git命令简易汇总&lt;/h3&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>missing-semester</title>
    <link href="http://example.com/2023/04/11/missing-semester/"/>
    <id>http://example.com/2023/04/11/missing-semester/</id>
    <published>2023-04-11T14:39:53.000Z</published>
    <updated>2023-05-19T14:24:28.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="topic-1-the-shell"><a class="markdownIt-Anchor" href="#topic-1-the-shell"></a> Topic 1: The Shell</h3><h4 id="what-is-the-shell"><a class="markdownIt-Anchor" href="#what-is-the-shell"></a> What is the shell?</h4><p>当我们用各种各样的电脑接口时，我们经常被从根本上限制了。为了充分利用计算机提供的工具，我们不得不走老路下降到文本界面：the Shell</p><p>几乎所有的平台都有一个shell，即使他们不同，在各个shell的核心，它们很大程度上相似：它们允许你去运行程序、接受输入、以半结构化的方式检查输出</p><p>在这节课，我们将会集中于Bourne Again Shell，即&quot;bash&quot;，它是众多shell中的一员，并且它的语法和其它shell很类似。如果我们想打开一个shell，我们需要一个终端</p><h4 id="using-the-shell"><a class="markdownIt-Anchor" href="#using-the-shell"></a> Using the shell</h4><p>首先，你会看到一个提示，通常看来是这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">missing:~$<br></code></pre></td></tr></table></figure><p>“missing&quot;是当前工作目录，”~“是&quot;home&quot;的缩写，”$&quot;指没有root权限。你能输入一个命令，将会被shell解释，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">missing:~$ date<br>Fri 10 Jan 2020 11:49:31 AM EST<br></code></pre></td></tr></table></figure><p>在这里，我们执行&quot;data&quot;程序，可以打印当前的事件，我么也可以执行一个带参数的程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">missing:~$ echo hello<br>hello<br></code></pre></td></tr></table></figure><p>在这个例子中，我们告诉shell使用参数<code>hello</code>执行<code>echo</code>，<code>echo</code>程序可以简单的打印它的参数。shell通过空格分割来解析命令，之后运行运行第一个单词指示的程序，之后的单词作为参数来提供程序访问。如果你想提供一个包括空格或者其他特殊符号（e.g，a directory named “My Photos”）作为参数，你能用<code>'</code>或者<code>&quot;</code>来包住</p><p>但是，shell怎么知道如何去找这个<code>date</code>或<code>echo</code>程序？shell就是一个变成环境，就像Python和Ruby语言一样，所以它有变量、条件、循环和函数，当用shell执行命令时，实际上是执行一小段shell解释的代码，如果shell被告知要执行一个找不到关键字的命令，它会查询一个名为<code>$PATH</code>的环境变量，这个变量列出了收到命令时应该搜索的程序的目录，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">missing:~$ echo $PATH<br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>missing:~$ which echo<br>/bin/echo<br>missing:~$ /bin/echo $PATH<br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br></code></pre></td></tr></table></figure><p>当我们运行<code>echo</code>命令，shell会知道它要执行<code>echo</code>命令，然后在<code>PATH</code>中以<code>:</code>为分隔符分离的目录列表中搜索该名称的文件，当它找到后，它会运行命令（假设这个文件可执行）。我们能使用<code>which</code>命令找出要执行的程序在哪个目录，我们也能通过给出要执行的文件的路径来绕过<code>$PATH</code>。</p><h4 id="navigating-in-the-shell"><a class="markdownIt-Anchor" href="#navigating-in-the-shell"></a> Navigating in the shell</h4><p>shell上的路径是一个带分隔符的目录列表，在Linux和macOS上用<code>/</code>分割，在Windows上用<code>\ </code>分割。在Linux中，路径<code>/</code>是文件系统的根目录，所有的目录和文件都位于该路径下而windows是<code>C:\</code>。可以用<code>pwd</code>获取当前目录。在路径中，<code>.</code>表示的是当前目录，<code>..</code>表示上级目录。</p><p>参考：<a href="https://missing.csail.mit.edu/2020/">https://missing.csail.mit.edu/2020/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;topic-1-the-shell&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#topic-1-the-shell&quot;&gt;&lt;/a&gt; Topic 1: The Shell&lt;/h3&gt;
&lt;h4 id=&quot;what-is-the-shell&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="课程笔记" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>DFS(搜索)</title>
    <link href="http://example.com/2023/04/11/DFS-%E6%90%9C%E7%B4%A2/"/>
    <id>http://example.com/2023/04/11/DFS-%E6%90%9C%E7%B4%A2/</id>
    <published>2023-04-11T04:22:11.000Z</published>
    <updated>2023-05-06T04:58:30.273Z</updated>
    
    <content type="html"><![CDATA[<p>  DFS为图论中的概念，详见<a href="">DFS(图论)</a>页面。在<strong>搜索算法</strong>中，该词常指利用递归函数方便地暴力枚举的算法，与图论中的DFS算法有一定相似之处，但并不完全相同<br />  比如一种例题，n 等于 m 个数相加之和，每个解从小到大排序，列举出解集。暴力求解是用m层循环，每层循环确定一个数，这样显然效率太低，就要用到<strong>递归搜索</strong>。<br />  该类算法的特点在于，将要搜索的目标分成若干层，每层基于前几层的状态进行决策，直到达到目标状态。考虑上述问题，即将正整数 n 分解成小于等于 m 个正整数之和，且排在后面的数必须<strong>大于等于</strong>前面的数<br />  设一组方案将正整数分解成k个正整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,.....,a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的和<br />  我们将问题分层，第 i 层决定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。则为了进行第 i 层决策，我们需要记录三个状态变量：后面所有正整数的和（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></msubsup><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">n-\sum_{j=1}^i{a_j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.400382em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>）、前一层的正整数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>）确保正整数递增；以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">i_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>确保最多输出m个正整数。<br />  为了方便记录方案，我们用arr数组，用第 i 项表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，注意到arr实际上是一个长度为 i 的栈<br />  代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> m, arr[<span class="hljs-number">103</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> a)</span></span>&#123;<span class="hljs-comment">//i是元素已有的个数，a是当前元素的值</span><br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i <span class="hljs-number">-1</span>; j ++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,arr[j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(i &lt;= m)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = a; j &lt;= n; j ++)&#123;<span class="hljs-comment">//遍历a之后的元素</span><br>arr[i] = j;<br><span class="hljs-built_in">dfs</span>(n - j, i + <span class="hljs-number">1</span>, j);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-built_in">dfs</span>(n, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>例题：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LeetCode 17. Letter Combinations of a Phone Number</a><br />难度：中等<br />题意：模拟九键拼音，输入2~9，每个按键对应三个英文字母，输入一个数字序列[123]，输出对应的所有英文组合<br />题解：<br />  力扣上的基础搜索回溯题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        vector&lt;string&gt; combinations;<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> combinations;<br>        &#125;<br>        unordered_map&lt;<span class="hljs-type">char</span>, string&gt; phoneMap&#123;<br>            &#123;<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>        &#125;;<span class="hljs-comment">//已经将key和value加入哈希表</span><br>        string combination;<br>        <span class="hljs-built_in">backtrack</span>(combinations, phoneMap, digits, <span class="hljs-number">0</span>, combination);<br>        <span class="hljs-keyword">return</span> combinations;<span class="hljs-comment">//返回包含所有符合的string向量</span><br>    &#125;<br>    <span class="hljs-comment">//注意函数参数的写法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;string&gt;&amp; combinations, <span class="hljs-type">const</span> unordered_map&lt;<span class="hljs-type">char</span>, string&gt;&amp; phoneMap, <span class="hljs-type">const</span> string&amp; digits, <span class="hljs-type">int</span> index, string&amp; combination)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">length</span>()) &#123;<br>            combinations.<span class="hljs-built_in">push_back</span>(combination);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span> digit = digits[index];<br>            string letters = phoneMap.<span class="hljs-built_in">at</span>(digit);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> letter: letters) &#123;<br>                combination.<span class="hljs-built_in">push_back</span>(letter);<br>                <span class="hljs-built_in">backtrack</span>(combinations, phoneMap, digits, index + <span class="hljs-number">1</span>, combination);<br>                combination.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>简化编写（建议学习正规写法）<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>: <br>    unordered_map&lt;<span class="hljs-type">char</span>, string&gt; phoneMap&#123;<br>        &#123;<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>    &#125;;<span class="hljs-comment">//已经将key和value加入哈希表</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        vector&lt;string&gt; combinations;<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> combinations;<br>        &#125;<br>        <br>        string combination;<br>        <span class="hljs-built_in">backtrack</span>(combinations, digits, <span class="hljs-number">0</span>, combination);<br>        <span class="hljs-keyword">return</span> combinations;<span class="hljs-comment">//返回包含所有符合的string向量</span><br>    &#125;<br>    <span class="hljs-comment">//注意函数参数的写法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;string&gt;&amp; combinations, string digits, <span class="hljs-type">int</span> index, string combination)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">length</span>()) &#123;<br>            combinations.<span class="hljs-built_in">push_back</span>(combination);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span> digit = digits[index];<br>            string letters = phoneMap[digit];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> letter: letters) &#123;<span class="hljs-comment">//循环</span><br>                combination.<span class="hljs-built_in">push_back</span>(letter);<span class="hljs-comment">//string也能用push_back和pop_back来加减元素</span><br>                <span class="hljs-built_in">backtrack</span>(combinations, digits, index + <span class="hljs-number">1</span>, combination);<br>                combination.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>参考：<a href="https://oi-wiki.org/search/dfs/">OI Wiki</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  DFS为图论中的概念，详见&lt;a href=&quot;&quot;&gt;DFS(图论)&lt;/a&gt;页面。在&lt;strong&gt;搜索算法&lt;/strong&gt;中，该词常指利用递归函数方便地暴力枚举的算法，与图论中的DFS算法有一定相似之处，但并不完全相同&lt;br /&gt;
  比如一种例题，n 等于 m 个数相加</summary>
      
    
    
    
    <category term="搜索" scheme="http://example.com/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>LRU缓存</title>
    <link href="http://example.com/2023/04/10/LRU%E7%BC%93%E5%AD%98/"/>
    <id>http://example.com/2023/04/10/LRU%E7%BC%93%E5%AD%98/</id>
    <published>2023-04-10T11:37:40.000Z</published>
    <updated>2023-04-10T12:30:48.637Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230410194125.png" alt="" /><br />难度：中等<br />链接：<a href="https://leetcode.cn/problems/lru-cache/">LeetCode 146. LRU Cache</a><br />题意：实现一个最近最少使用缓存的数据结构，事先给出缓存区大小，进来一个元素，如果是满的就把最长时间未用的元素挤出去<br />题解：<br />  手写一个双向链表来存储结点，用哈希表unorder_map（便于查找）来定位&lt;key,value&gt;对，其中value是双向链表的结点。靠近头部的是最新的，靠近尾部的是最久未使用的。<br />  先用哈希表定位，然后找出缓存项的位置，然后操作<br />  对于get操作，若存在，用哈希表定位位置（DLinkedNode *node = cache[key]），然后移动到头结点（注意移动操作是先删除结点后插入到头结点，所以时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>），最后返回该结点的值<br />  对于put操作，若存在，和get类似，需要更新value；若不存在，创建一个新结点插入到头结点，若size超量，删除尾结点，并erase对应项</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//手写双向链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br><span class="hljs-type">int</span> key,value;<br>DLinkedNode *prev;<br>DLinkedNode *next;<br><span class="hljs-built_in">DLinkedNode</span>(): <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>),<span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br><span class="hljs-built_in">DLinkedNode</span>(<span class="hljs-type">int</span> _key,<span class="hljs-type">int</span> _value): <span class="hljs-built_in">key</span>(_key),<span class="hljs-built_in">value</span>(_value),<span class="hljs-built_in">prev</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//unordered_map内部实现是哈希表，无序的，优点便于查找</span><br>unordered_map&lt;<span class="hljs-type">int</span>,DLinkedNode*&gt; cache;<span class="hljs-comment">//前数值后结点</span><br>DLinkedNode *head;<span class="hljs-comment">//虚拟头节点</span><br>DLinkedNode* tail;<span class="hljs-comment">//虚拟尾结点</span><br><span class="hljs-type">int</span> size;<br><span class="hljs-type">int</span> capacity;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> _capacity): <span class="hljs-built_in">capacity</span>(_capacity),<span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//初始化</span><br>head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>head-&gt;next = tail;<br>tail-&gt;next = head;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br><span class="hljs-comment">//map的count(key)函数判断是否存在元素</span><br><span class="hljs-comment">//区别是即使元素=0，count也返回1</span><br><span class="hljs-comment">//对应的erase(key)函数是清除记录</span><br><span class="hljs-keyword">if</span>(!cache.<span class="hljs-built_in">count</span>(key))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//如果存在，先通过哈希表定位，再转移到头部（更新）</span><br>DLinkedNode *node = cache[key];<br><span class="hljs-built_in">moveToHead</span>(node);<br><span class="hljs-keyword">return</span> node-&gt;value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(!cache.<span class="hljs-built_in">count</span>(key))&#123;<br><span class="hljs-comment">//如果不存在，创建一个新的结点</span><br>DLinkedNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>(key,value);<br><span class="hljs-comment">//添加进哈希表</span><br>cache[key] = node;<br><span class="hljs-comment">//添加至双向链表的头部</span><br><span class="hljs-built_in">addToHead</span>(node);<br>size++;<br><br><span class="hljs-keyword">if</span>(size &gt; capacity)&#123;<br><span class="hljs-comment">//如果超出容量，删除双向链表的尾部结点</span><br>DLinkedNode *removed = <span class="hljs-built_in">removeTail</span>();<br><span class="hljs-comment">//删除哈希表中对应的项</span><br>cache.<span class="hljs-built_in">erase</span>(removed-&gt;key);<br><span class="hljs-comment">//防止内存泄漏</span><br><span class="hljs-keyword">delete</span> removed;<br>size--;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//若存在，先通过哈希表定位，再更新value，并转移到头部</span><br>DLinkedNode *node = cache[key];<br>node-&gt;value = value;<br><span class="hljs-built_in">moveToHead</span>(node);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode *node)</span></span>&#123;<br><span class="hljs-comment">//将node添加到双向链表头结点</span><br>node-&gt;prev = head;<br>node-&gt;next = head-&gt;next;<br>head-&gt;next-&gt;prev = node;<br>head-&gt;next = node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode *node)</span></span>&#123;<br><span class="hljs-comment">//删除结点</span><br>node-&gt;prev-&gt;next = node-&gt;next;<br>node-&gt;next-&gt;prev = node-&gt;prev;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode *node)</span></span>&#123;<br><span class="hljs-comment">//将结点移到头结点，直接删除和添加结点，所以是O(1)</span><br><span class="hljs-built_in">removeNode</span>(node);<br><span class="hljs-built_in">addToHead</span>(node);<br>&#125;<br><br><span class="hljs-function">DLinkedNode *<span class="hljs-title">removeTail</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//删除尾结点</span><br>DLinkedNode *node = tail-&gt;prev;<br><span class="hljs-built_in">removeNode</span>(node);<br><span class="hljs-keyword">return</span> node;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230410194125.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
难度：中等&lt;br /&gt;
链接：&lt;a href=&quot;https://lee</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="哈希" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>链表排序</title>
    <link href="http://example.com/2023/04/08/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/04/08/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/</id>
    <published>2023-04-08T13:47:58.000Z</published>
    <updated>2023-04-09T14:57:09.561Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />链接：<a href="https://leetcode.cn/problems/sort-list/">Sort List</a><br />题意：在时间复杂度为O(nlogn)内，空间复杂度为O(1)内对给定首元结点的链表排序</p><h5 id="归并排序递归实现自顶向下"><a class="markdownIt-Anchor" href="#归并排序递归实现自顶向下"></a> 归并排序（递归实现自顶向下）</h5><p>  归并排序的思想是：将数组拆分成两半，对两半再进行归并排序，最后进行有序合并<br />  时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br />  若要在链表中实现归并排序（递归法），需要以下子方法：</p><ul><li>ListNode *findMid(ListNode *head) 找到链表中点：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双指针找链表中点，偶数个结点时取中间偏左的结点</span><br><span class="hljs-function">ListNode *<span class="hljs-title">findMid</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br><span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;<br><br>ListNode *fast = head-&gt;next;<br>ListNode *slow = head;<br><span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>fast=fast-&gt;next-&gt;next;<br>slow=slow-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ListNode *mergeSort(ListNode *head) 每次找到链表中点，断开，对两边再进行mergeSort</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">mergeSort</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>    <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>        ListNode *mid = <span class="hljs-built_in">findMid</span>(head);<br>        <br>        ListNode *next = mid-&gt;next;<br>        mid-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//断开mid和下一个结点</span><br>        ListNode *left = <span class="hljs-built_in">mergeSort</span>(head);<br>        ListNode *right = <span class="hljs-built_in">mergeSort</span>(next);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(left,right);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>ListNode *merge(ListNode *l1,ListNode *l2) 合并两个升序的链表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(ListNode *l1,ListNode *l2)</span></span>&#123;<br>ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//新建个链表</span><br>ListNode *curr = dummy;<br><span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;<br>curr-&gt;next = l1;<br>l1 = l1-&gt;next;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>curr-&gt;next = l2;<br>l2 = l2-&gt;next;<br>&#125;<br>curr = curr-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">NULL</span>)&#123;<br>curr-&gt;next = l1;<br>&#125;<br><span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">NULL</span>)&#123;<br>curr-&gt;next = l2;<br>&#125;<br><span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最终代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode *<span class="hljs-title">findMid</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;<br><br>        ListNode *fast = head-&gt;next;<br>        ListNode *slow = head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeSort</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>    <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>        ListNode *mid = <span class="hljs-built_in">findMid</span>(head);<br>        <br>        ListNode *next = mid-&gt;next;<br>        mid-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//断开mid和下一个结点</span><br>        ListNode *left = <span class="hljs-built_in">mergeSort</span>(head);<br>        ListNode *right = <span class="hljs-built_in">mergeSort</span>(next);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(left,right);<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(ListNode *l1,ListNode *l2)</span></span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//新建个链表</span><br>        ListNode *curr = dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;<br>                curr-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                curr-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            curr = curr-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">NULL</span>)&#123;<br>            curr-&gt;next = l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">NULL</span>)&#123;<br>            curr-&gt;next = l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(head);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="归并排序迭代实现自底向上"><a class="markdownIt-Anchor" href="#归并排序迭代实现自底向上"></a> 归并排序（迭代实现自底向上）</h5><p>  用迭代实现可以达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的时间复杂度和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的空间复杂度<br />  想法是先把数组分割成含有1个结点的子链表，分割后从头开始每相邻两个子链表有序合并，然后step增大一倍变为2，再相邻有序合并，step增大一倍变为4，持续合并，最后就成了一个有序链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        <span class="hljs-comment">//获取链表长度</span><br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        ListNode *curr = head;<br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>        len ++;<br>        curr = curr-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//循环遍历</span><br>        <span class="hljs-comment">//外层遍历step，内层处理每step个元素进行一次merge</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> step = <span class="hljs-number">1</span>; step &lt; len; step *= <span class="hljs-number">2</span>)&#123;<br>        ListNode *tail = dummy;<br>        curr = dummy-&gt;next;<br>        <br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">//left和right是两个相邻的链表，各有step个元素</span><br>        ListNode *left = curr;<br>        ListNode *right = <span class="hljs-built_in">cut</span>(left,step);<br>        <span class="hljs-comment">//巧用cut使成为curr下次开始的点</span><br>        curr = <span class="hljs-built_in">cut</span>(right,step);<br>        <span class="hljs-comment">//tail用来连接链表</span><br>        tail-&gt;next = <span class="hljs-built_in">merge</span>(left,right);<br>        <span class="hljs-keyword">while</span>(tail-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>        tail = tail-&gt;next;<br>        &#125;<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode *<span class="hljs-title">cut</span><span class="hljs-params">(ListNode *from,<span class="hljs-type">int</span> step)</span></span>&#123;<br>    <span class="hljs-comment">//将链表从from开始切掉前step个元素，返回后一个元素（断链</span><br>    step --;<br>    <span class="hljs-keyword">while</span>(from != <span class="hljs-literal">NULL</span> &amp;&amp; step &gt;<span class="hljs-number">0</span>)&#123;<br>    from = from-&gt;next;<br>    step --;<br>    &#125;<br>    <span class="hljs-comment">//包括from，切掉</span><br>    <span class="hljs-keyword">if</span>(from == <span class="hljs-literal">NULL</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//到了尾结点，返回NULL</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    ListNode *next = from-&gt;next;<br>    from-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//断链</span><br>    <span class="hljs-keyword">return</span> next;<span class="hljs-comment">//返回from-&gt;next;</span><br>    &#125;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(ListNode *l1,ListNode *l2)</span></span>&#123;<br>    <span class="hljs-comment">//合并两个有序链表</span><br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//新建个链表</span><br>        ListNode *curr = dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;<br>                curr-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                curr-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            curr = curr-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">NULL</span>)&#123;<br>            curr-&gt;next = l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">NULL</span>)&#123;<br>            curr-&gt;next = l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>参考：<br />  <a href="https://leetcode.cn/problems/sort-list/solution/by-nuo-nuo-zi-4-xrok/">https://leetcode.cn/problems/sort-list/solution/by-nuo-nuo-zi-4-xrok/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
链接：&lt;a href=&quot;https://leetcode.cn/problems/sort-list/&quot;&gt;Sort List&lt;/a&gt;&lt;br /&gt;
题意：在时间复杂度为O(nlogn)内，空间复杂度为O(1)内对给定首元结点的链表排序&lt;/p&gt;
&lt;h5 </summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Vim简单应用</title>
    <link href="http://example.com/2023/04/08/Vim%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2023/04/08/Vim%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</id>
    <published>2023-04-08T09:35:07.000Z</published>
    <updated>2023-04-09T15:16:55.593Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-模式转换"><a class="markdownIt-Anchor" href="#1-模式转换"></a> 1、模式转换</h5><ul><li>命令行模式可以输入<code>i、a</code>等进入编辑模式</li><li>编辑模式点击<code>esc</code>按键进入命令行模式</li><li>命令行模式点击<code>shift+;</code>进入低行模式</li></ul><h5 id="2-编辑模式"><a class="markdownIt-Anchor" href="#2-编辑模式"></a> 2、编辑模式</h5><ul><li>i 从目前光标所在处插入</li><li>I 在当前所在行的第一个非空字符处插入，可用0i替代</li><li>a 从当面光标所在的下一个字符处插入</li><li>A 从当前光标所在行的最后一个字符处开始插入，可以用$a替代</li><li>o 在当前光标所在的下一行处插入新的一行</li><li>O 在当前光标所在的上一行后插入新的一行</li><li>s 删除光标所在字符并开始插入</li><li>S 删除光标所在行并开始插入</li></ul><h5 id="3-低行模式"><a class="markdownIt-Anchor" href="#3-低行模式"></a> 3、低行模式</h5><ul><li>:w 保存文件但不退出vim</li><li>:w file 将修改另外保存到file中，不退出vim</li><li>:!w 强制保存，不推出vim</li><li>:wq 保存文件并退出vim</li><li>:!wq 强制保存文件，并退出vim</li><li>:q 不保存文件，退出vi</li><li>:!q 不保存文件，强制退出vim</li><li>:!e 放弃所有修改，从上次保存文件开始再编辑命令历史</li></ul><h5 id="4-光标移动"><a class="markdownIt-Anchor" href="#4-光标移动"></a> 4、光标移动</h5><ul><li>h 左移、l 右移、j 下移、k 上移</li><li>n+空格 移动到这行该字符后第n个字符</li><li>0 移动到该行最前面字符处</li><li>^ 移动到该行最前面非空字符处</li><li>$ 移动到该行最后</li><li>gg 移动到第一行</li><li>G 移动到最后一行</li><li>ngg 或 nG 移动到第n行</li><li>n 移动到光标下n行</li></ul><h5 id="5-撤回-删除-复制和粘贴"><a class="markdownIt-Anchor" href="#5-撤回-删除-复制和粘贴"></a> 5、撤回、删除、复制和粘贴</h5><ul><li>u 撤销上一步操作</li><li>ctrl+r 恢复上一步被撤销的操作</li><li>. 重复上一步操作</li><li>nx 向后删除n个字符</li><li>X 向前删除一个字符</li><li>ndd 删除光标所在的向下n行</li><li>d1G 删除光标所在到第一行的全部数据</li><li>dG 删除光标到最后一行</li><li>d$ 删除光标到该行最后一个字符</li><li>d0 删除光标到该行第一个字符</li><li>nyy 复制光标所在的向下n行</li><li>y1G 复制光标所在到第一行的全部数据</li><li>yG 复制光标到最后一行</li><li>y$ 复制光标到该行最后一个字符</li><li>y0 复制光标到该行第一个字符</li><li>p 粘贴到光标所在的前一行</li><li>P 粘贴到光标所在的后一行</li><li>J 光标所在行与下一行的数据结合成一行</li></ul><h5 id="6-搜索与替换"><a class="markdownIt-Anchor" href="#6-搜索与替换"></a> 6、搜索与替换</h5><ul><li>/word 光标向下搜索并高亮第一个word</li><li>搜索到后，n 向下搜索下一个word，N 向上反向</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-模式转换&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-模式转换&quot;&gt;&lt;/a&gt; 1、模式转换&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;命令行模式可以输入&lt;code&gt;i、a&lt;/code&gt;等进入编辑模式&lt;/li&gt;
&lt;li&gt;编辑模式点击&lt;code&gt;</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>找出环形链表的入环第一个结点</title>
    <link href="http://example.com/2023/04/07/%E6%89%BE%E5%87%BA%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E7%8E%AF%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2023/04/07/%E6%89%BE%E5%87%BA%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E7%8E%AF%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2023-04-07T13:57:04.000Z</published>
    <updated>2023-04-07T15:11:57.628Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">Linked List Cycle II</a><br />题意：给一个可能有环的链表，若不存在环输出-1，找出入环的第一个结点并返回<br />题解：</p><h5 id="方法一哈希表"><a class="markdownIt-Anchor" href="#方法一哈希表"></a> 方法一：哈希表</h5><p>  因为每个结点是不同的，所以就可以用哈希表存每个结点，一旦遇到重复结点就一定有环<br />  缺点：用时和占用内存都比较大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-comment">//用map也可实现</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        map&lt;ListNode *,<span class="hljs-type">int</span>&gt; visited;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited[head]!=<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            visited[head]++;<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class Solution &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="hljs-comment">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="hljs-comment">        while (head != nullptr) &#123;</span><br><span class="hljs-comment">            if (visited.count(head)) &#123;</span><br><span class="hljs-comment">                return head;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            visited.insert(head);</span><br><span class="hljs-comment">            head = head-&gt;next;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return nullptr;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="双指针法"><a class="markdownIt-Anchor" href="#双指针法"></a> 双指针法</h5><p><img src="https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230407231129.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *slow=head,*fast=head;<br><span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>)&#123;<br>slow=slow-&gt;next;<br><span class="hljs-keyword">if</span>(fast-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>fast=fast-&gt;next-&gt;next;<br><span class="hljs-keyword">if</span>(fast==slow)&#123;<br>ListNode *ptr=head;<br><span class="hljs-keyword">while</span>(ptr!=slow)&#123;<br>ptr=ptr-&gt;next;<br>slow=slow-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> ptr;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
链接：&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle-ii/&quot;&gt;Linked List Cycle II&lt;/a&gt;&lt;br /&gt;
题意：给一个可能有环的链表，若不存在环输出-1，找出入环的第</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>对链表插入排序</title>
    <link href="http://example.com/2023/04/05/%E5%AF%B9%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/04/05/%E5%AF%B9%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2023-04-05T14:16:17.000Z</published>
    <updated>2023-04-05T14:52:45.003Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />题目链接：<a href="https://leetcode.cn/problems/insertion-sort-list/">LeetCode 147. Insertion Sort List</a><br />题意：给出首元结点为head的链表，用插入排序来让这个链表有序<br />题解：<br />   插入排序的本质是维护一个有序数组，每次将待排序元素插入到这个数组中。在链表中，只需要有序数组的最后一个元素lastsorted还有待排序元素curr即可，如果curr大于lastsorted就不管，如果curr小于lastsorted的话，就定义一个pre找到待插入位置，先把curr隐去，然后把curr插入过去就行，然后curr=lastsorted-&gt;next即可<br />  这种方法每次只需比较相邻的两个结点大小，如果curr小就遍历一遍前面的元素然后插入，如果大就不管，时间复杂度控制的好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* lastSorted = head;<br>        ListNode* curr = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (lastSorted-&gt;val &lt;= curr-&gt;val) &#123;<br>                lastSorted = lastSorted-&gt;next;<br>            &#125; <br>            <span class="hljs-keyword">else</span> &#123;<br>                ListNode *prev = dummyHead;<br>                <span class="hljs-keyword">while</span> (prev-&gt;next-&gt;val &lt;= curr-&gt;val) &#123;<br>                    prev = prev-&gt;next;<br>                &#125;<br>                lastSorted-&gt;next = curr-&gt;next;<span class="hljs-comment">//隐去curr结点</span><br>                curr-&gt;next = prev-&gt;next;<br>                prev-&gt;next = curr;<span class="hljs-comment">//插入curr结点</span><br>            &#125;<br>            curr = lastSorted-&gt;next;<span class="hljs-comment">//注意curr结点可以重用</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
题目链接：&lt;a href=&quot;https://leetcode.cn/problems/insertion-sort-list/&quot;&gt;LeetCode 147. Insertion Sort List&lt;/a&gt;&lt;br /&gt;
题意：给出首元结点为head的链</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>合并有序链表</title>
    <link href="http://example.com/2023/04/04/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/04/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-04T13:42:25.000Z</published>
    <updated>2023-04-05T14:53:10.899Z</updated>
    
    <content type="html"><![CDATA[<p>难度：简单<br />链接：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a><br />题意：给两个有序链表，将其合并为一个链表并返回首元结点。<br />题解：<br />  假设将list2合并到list1上，先定义虚拟头结点和pre，遍历两个链表，如果list2&gt;list1，就让list1和pre后移，否则list2&lt;=list1将q-&gt;val=list2-&gt;val插入到pre和list之间。遍历到list2结束，如果此时list1有剩余可以不处理，如果list2有剩余，就让pre-&gt;next=list2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode *dummynode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummynode-&gt;next=list1;<span class="hljs-comment">//定义头结点很方便</span><br>        ListNode *pre=dummynode;<br>        <span class="hljs-keyword">while</span>(list1!=<span class="hljs-literal">NULL</span>&amp;&amp;list2!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list2-&gt;val&gt;list1-&gt;val)&#123;<br>                list1=list1-&gt;next;<br>                pre=pre-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ListNode *q=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>                q-&gt;val=list2-&gt;val;<br>                pre-&gt;next=q;<br>                q-&gt;next=list1;<br>                list2=list2-&gt;next; <br>                pre=pre-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list1==<span class="hljs-literal">NULL</span>)&#123;<br>            pre-&gt;next=list2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummynode-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：简单&lt;br /&gt;
链接：&lt;a href=&quot;https://leetcode.cn/problems/merge-two-sorted-lists/&quot;&gt;https://leetcode.cn/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;br</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>重排链表</title>
    <link href="http://example.com/2023/04/03/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/03/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-03T10:14:24.000Z</published>
    <updated>2023-04-07T13:05:09.113Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />题目链接：<a href="https://leetcode.cn/problems/reorder-list/">https://leetcode.cn/problems/reorder-list/</a><br /><img src="https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230403182251.png" alt="" /><br />题解：</p><h5 id="方法一寻找链表中点反转链表合并链表"><a class="markdownIt-Anchor" href="#方法一寻找链表中点反转链表合并链表"></a> 方法一：寻找链表中点+反转链表+合并链表</h5><p>注意到结果正是把链表中点的后半反转后（不包括中点，且偶数结点中中点是中间两个结点的后者），邻一个插入到前半链表，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><br />代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode *head)</span> <span class="hljs-comment">// 找链表中点</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *first = head, *second = head; <span class="hljs-comment">// 快慢指针</span><br>        <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">NULL</span> &amp;&amp; first-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            first = first-&gt;next-&gt;next;<br>            second = second-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> <span class="hljs-comment">// 迭代法将中点后反转链表</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode *curr = head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ListNode *nextTemp = curr-&gt;next;<br>            curr-&gt;next = prev;<br>            prev = curr;<br>            curr = nextTemp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(ListNode *l1, ListNode *l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *l1_tmp;<br>        ListNode *l2_tmp;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            l1_tmp = l1-&gt;next; <span class="hljs-comment">// 因为要改变结点的next</span><br>            l2_tmp = l2-&gt;next; <span class="hljs-comment">// 所以先用tmp结点存当前结点的next结点</span><br><br>            l1-&gt;next = l2;<br>            l1 = l1_tmp;<br><br>            l2-&gt;next = l1;<br>            l2 = l2_tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode *mid = <span class="hljs-built_in">middleNode</span>(head); <span class="hljs-comment">// 找中点或偶数中点后一个结点</span><br>        ListNode *l1 = head;<br>        ListNode *l2 = mid-&gt;next; <span class="hljs-comment">// 两段链表</span><br>        mid-&gt;next = <span class="hljs-literal">NULL</span>;         <span class="hljs-comment">// 断链</span><br>        l2 = <span class="hljs-built_in">reverseList</span>(l2);     <span class="hljs-comment">// 反转链表</span><br>        <span class="hljs-built_in">mergeList</span>(l1, l2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="方法二线性表"><a class="markdownIt-Anchor" href="#方法二线性表"></a> 方法二：线性表</h5><p>由于链表不支持下标访问，所以无法随机访问链表的元素，可以用vector来当作线性表存链表结点<br />此方法空间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，用线性表比较大<br />代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//因为是void型，直接用return结束</span><br>        &#125;<br>        vector&lt;ListNode *&gt; vec;<br>        ListNode *node = head;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(node);<br>            node = node-&gt;next;<span class="hljs-comment">//线性表vec存链表结点</span><br>        &#125;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j)<br>        &#123;<br>            vec[i]-&gt;next = vec[j];<br>            i++;<br>            <span class="hljs-keyword">if</span> (i == j)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            vec[j]-&gt;next = vec[i];<br>            j--;<span class="hljs-comment">//用i++和j--可以找下一个变量和上一个变量</span><br>        &#125;<br>        vec[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
题目链接：&lt;a href=&quot;https://leetcode.cn/problems/reorder-list/&quot;&gt;https://leetcode.cn/problems/reorder-list/&lt;/a&gt;&lt;br /&gt;
&lt;img src=&quot;http</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/2023/04/03/%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/03/%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-03T10:04:57.000Z</published>
    <updated>2023-04-03T11:00:11.854Z</updated>
    
    <content type="html"><![CDATA[<p>示例代码：包括两种方法建立，查找，删除，输出，反转，找中点，交叉合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> n, i;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span><br>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;<br>&#125; *List, node; <span class="hljs-comment">// List和node * 同义</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeadCreatList</span><span class="hljs-params">(List H)</span> <span class="hljs-comment">// 头插法</span></span><br><span class="hljs-function"></span>&#123;<br>    node *p;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        p = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(List));<br>        p-&gt;data = a[i];<br>        p-&gt;next = H-&gt;next;<br>        H-&gt;next = p;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailCreatList</span><span class="hljs-params">(List H)</span> <span class="hljs-comment">// 尾插法</span></span><br><span class="hljs-function"></span>&#123;<br>    node *p, *r;<br>    r = H; <span class="hljs-comment">// r是尾指针，一直指向最后一个结点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        p = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(List));<br>        p-&gt;data = a[i];<br>        r-&gt;next = p;<br>        r = p;<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// r是最后一个结点，最后一个节点后接空</span><br>&#125;<br><br><span class="hljs-function">node *<span class="hljs-title">Search</span><span class="hljs-params">(List H, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> *w)</span> <span class="hljs-comment">// 查找x在链表中的下标</span></span><br><span class="hljs-function"></span>&#123;<br>    node *p;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    p = H-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;data != x)<br>    &#123;<br>        p = p-&gt;next;<br>        n++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        *w = n + <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为当p-&gt;data==x时就跳出循环，所以加1</span><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        *w = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(List H, <span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 删除为x的数据</span></span><br><span class="hljs-function"></span>&#123;<br>    node *pre, *p, *q;<br>    pre = H;     <span class="hljs-comment">// pre用作前驱</span><br>    p = H-&gt;next; <span class="hljs-comment">// p是当前结点</span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;data == x)<br>        &#123;<br>            q = p; <span class="hljs-comment">// 存结点</span><br>            pre-&gt;next = p-&gt;next;<br>            p = pre-&gt;next;<br>            <span class="hljs-built_in">free</span>(q); <span class="hljs-comment">// 释放结点</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pre = pre-&gt;next;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(List H, <span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 将x插入链表中的第一个大于它的数的前边</span></span><br><span class="hljs-function"></span>&#123;<br>    node *pre, *p, *q;<br>    pre = H; <span class="hljs-comment">// 前驱</span><br>    p = H-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;data &lt; x)<br>    &#123; <span class="hljs-comment">// p停在第一个大于等于x的结点</span><br>        pre = pre-&gt;next;<br>        p = p-&gt;next;<br>    &#125;<br>    q = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(List));<br>    q-&gt;data = x;<br>    pre-&gt;next = q;<br>    q-&gt;next = p;<br>&#125; <span class="hljs-comment">// 若想创建一个有序的链表，就输入每个值然后调用一次Insert就好</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List H)</span></span><br><span class="hljs-function"></span>&#123;<br>    node *p;<br>    p = H-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(node *head)</span> <span class="hljs-comment">// 反转链表，注意这里head是H-&gt;next</span></span><br><span class="hljs-function"></span>&#123;<br>    node *pre, *p;<br>    pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// pre一开始在头结点</span><br>    p = head;   <span class="hljs-comment">// p一开始在首元结点</span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        node *q = p-&gt;next;<br>        p-&gt;next = pre; <span class="hljs-comment">// 改变p点的指针指向</span><br>        pre = p;       <span class="hljs-comment">// 将pre移向下一个结点</span><br>        p = q;         <span class="hljs-comment">// 将p移向下一个结点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function">node *<span class="hljs-title">middleNode</span><span class="hljs-params">(node *head)</span> <span class="hljs-comment">// 找链表中点，注意这里head是H-&gt;next</span></span><br><span class="hljs-function"></span>&#123;<br>    node *first = head, *second = head; <span class="hljs-comment">// 快慢指针</span><br>    <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">NULL</span> &amp;&amp; first-&gt;next != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        first = first-&gt;next-&gt;next;<br>        second = second-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(node *l1, node *l2)</span> <span class="hljs-comment">// 相邻挨个插入</span></span><br><span class="hljs-function"></span>&#123;<br>    node *l1_tmp;<br>    node *l2_tmp;<br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        l1_tmp = l1-&gt;next; <span class="hljs-comment">// 因为要改变结点的next</span><br>        l2_tmp = l2-&gt;next; <span class="hljs-comment">// 所以先用tmp结点存当前结点的next结点</span><br><br>        l1-&gt;next = l2;<br>        l1 = l1_tmp;<br><br>        l2-&gt;next = l1;<br>        l2 = l2_tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    &#125;<br>    List H;<br>    H = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(List));<br>    H-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-built_in">TailCreatList</span>(H);<br>    <span class="hljs-built_in">print</span>(H);<br><br>    <span class="hljs-type">int</span> x, w;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要查找的数据：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    node *z = <span class="hljs-built_in">Search</span>(H, x, &amp;w);<br>    <span class="hljs-keyword">if</span> (z == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不在链表中\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在链表中下标为：%d\n&quot;</span>, w);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的数据：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    <span class="hljs-built_in">Delete</span>(H, x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除后：&quot;</span>);<br>    <span class="hljs-built_in">print</span>(H);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要插入的数据（递增）：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    <span class="hljs-built_in">Insert</span>(H, x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入后：&quot;</span>);<br>    <span class="hljs-built_in">print</span>(H);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;示例代码：包括两种方法建立，查找，删除，输出，反转，找中点，交叉合并&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>反转部分链表</title>
    <link href="http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-02T14:35:50.000Z</published>
    <updated>2023-04-03T10:17:07.107Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">https://leetcode.cn/problems/reverse-linked-list-ii/description/</a><br />题意：反转链表的一部分，从left到right，例如[1,2,3,4,5]，left=2，right=4时，解为[1,4,3,2,5]</p><p>题解：反转部分链表可实现，但是反转后如何连接起来需要考虑，即将left-1与right、left与right+1连接起来，需要记录这些结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseLinklist</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>ListNode *pre,*p;<br>        pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pre一开始在头结点</span><br>        p=head;<span class="hljs-comment">//p一开始在首元结点</span><br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            ListNode *q=p-&gt;next;<br>            p-&gt;next=pre;<span class="hljs-comment">//改变p点的指针指向</span><br>            pre=p;<span class="hljs-comment">//将pre移向下一个结点</span><br>            p=q;<span class="hljs-comment">//将p移向下一个结点</span><br>        &#125;<br>        <span class="hljs-comment">//不需要返回，因为结点名称不变</span><br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>ListNode *dummyhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>dummyhead-&gt;next=head;<span class="hljs-comment">//定义虚拟头结点，因为首元结点可能变化</span><br><br>ListNode *pre = dummyhead;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;left<span class="hljs-number">-1</span>;i++)&#123;<br>pre=pre-&gt;next;<span class="hljs-comment">//从头结点走left-1步，定格在left-1结点处</span><br>&#125;<br><br>ListNode *rightNode = pre;<span class="hljs-comment">//接力pre结点，继续往下循环</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left + <span class="hljs-number">1</span> ; i++)&#123;<br>rightNode = rightNode-&gt;next;<span class="hljs-comment">//rightNode循环到right结点</span><br>&#125;<br><br>ListNode *leftNode = pre-&gt;next;<span class="hljs-comment">//指向left</span><br>ListNode *curr = rightNode-&gt;next;<span class="hljs-comment">//指向right+1</span><br><br>pre-&gt;next = <span class="hljs-literal">NULL</span>;<br>rightNode-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//切断链接，截取链表</span><br><br><span class="hljs-built_in">reverseLinklist</span>(leftNode);<span class="hljs-comment">//反转部分链表，各结点位置不变</span><br><br>pre-&gt;next=rightNode;<span class="hljs-comment">//连接前部分</span><br>leftNode-&gt;next=curr;<span class="hljs-comment">//连接后部分</span><br><span class="hljs-keyword">return</span> dummyhead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
题目链接：&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list-ii/description/&quot;&gt;https://leetcode.cn/problems/reverse-linked-l</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-02T12:47:07.000Z</published>
    <updated>2023-04-03T13:20:57.862Z</updated>
    
    <content type="html"><![CDATA[<p>难度：简单<br />题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a><br />题意：给出一个链表的头结点（首元结点），将该链表反转后，返回反转后的链表<br />题解：</p><h5 id="方法一迭代"><a class="markdownIt-Anchor" href="#方法一迭代"></a> 方法一：迭代</h5><p>直接在遍历链表的过程中原地修改，将当前结点的next指针改为指向前一个节点，然后将p和pre结点都后移，需要借助p的后面结点，所以循环的开始先定义一个q=p-&gt;next;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *pre,*p;<br>        pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pre一开始在头结点</span><br>        p=head;<span class="hljs-comment">//p一开始在首元结点</span><br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            ListNode *q=p-&gt;next;<br>            p-&gt;next=pre;<span class="hljs-comment">//改变p点的指针指向</span><br>            pre=p;<span class="hljs-comment">//将pre移向下一个结点</span><br>            p=q;<span class="hljs-comment">//将p移向下一个结点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<span class="hljs-comment">//遍历到结尾时，pre在最后一个结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="方法二递归"><a class="markdownIt-Anchor" href="#方法二递归"></a> 方法二：递归</h5><p>一直递归到倒数第二个结点，找到结果头结点newhead，然后执行head-&gt;next-&gt;next=null反转最后一个结点和倒数第二个结点的指针，改变head-&gt;next=NULL，然后回退挨个反转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>||head-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//为什么head==NULL?  测试用例有空链表</span><br>            <span class="hljs-keyword">return</span> head;<span class="hljs-comment">//最后返回的是最后一个结点，让newhead等于最后一个结点</span><br>        &#125;<br>        ListNode *newhead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<span class="hljs-comment">//注意，只会执行一次</span><br>        head-&gt;next-&gt;next=head;<span class="hljs-comment">//该行代码第一次执行时是倒数第二个结点，反转指针</span><br>        head-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//提前定义空指针</span><br>        <span class="hljs-keyword">return</span> newhead;<span class="hljs-comment">//一直返回最后的头结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：简单&lt;br /&gt;
题目链接：&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list/description/&quot;&gt;https://leetcode.cn/problems/reverse-linked-list</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>迭代&amp;递归&amp;分治</title>
    <link href="http://example.com/2023/04/02/%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/"/>
    <id>http://example.com/2023/04/02/%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/</id>
    <published>2023-04-02T12:02:43.000Z</published>
    <updated>2023-04-09T15:17:41.514Z</updated>
    
    <content type="html"><![CDATA[<h4 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h4><p>1.迭代法称为辗转法，不断的用变量旧值求出新值，即对一组指令循环执行，最终得到新值作为结果。<br />2.在代码中表现为在一个循环内，不断循环最终得到结果。</p><h4 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h4><p>1.定义：递归在数学和计算机科学中指在函数的定义中使用函数自身的方法，还额外指一种通过重复将问题分解为同类子问题而解决问题的方法。基本思想是某个函数直接或间接地调用自身，在求解过程中只需关注如何把原问题划分成符合条件的子问题，不需要过分关注子问题如何解决。<br />2.特征：<strong>结束条件</strong>和<strong>自我调用</strong>，示例概括代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(传入数值)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件)<br>        <span class="hljs-keyword">return</span> 最小子问题解;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(缩小规模);<br>&#125;<br></code></pre></td></tr></table></figure><p>3.缺点：在程序执行中，递归是利用堆栈实现的，每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧，递归层数过多会栈溢出。简单的递归不会消耗空间，比如给出链表头，计算长度的递归代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size_recursion</span><span class="hljs-params">(Node *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">size_recursion</span>(head-&gt;next) + <span class="hljs-number">1</span>;<span class="hljs-comment">//有一个结点加一次1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分治"><a class="markdownIt-Anchor" href="#分治"></a> 分治</h4><p>1.定义：把一个复杂问题分成多个相同或相似的子问题，直到最后子问题都可以直接求解，原问题即子问题的解的合并。分治问题能通过递归算法解决，也能通过非递归算法解决，通常用递归算法<br />2.过程：</p><ul><li>分解原问题为结构相同的子问题</li><li>分解到某个容易求解的边界之后，进行递归求解</li><li>将子问题的解合并成原问题的解<br />3.能解决的问题特征：</li><li>该问题的规模缩小到一定程度就可以容易地解决</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并成该问题的解</li><li>该问题所分解出的各个子问题是<strong>相互独立</strong>的，即子问题之间不包含公共的子问题。(若子问题不相互独立，一般用动态规划)<br />4.分治与递归的区别：递归是一种变成技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体的算法思想。</li></ul><p>参考：<br />  <a href="https://oi.wiki">https://oi.wiki</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;迭代&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#迭代&quot;&gt;&lt;/a&gt; 迭代&lt;/h4&gt;
&lt;p&gt;1.迭代法称为辗转法，不断的用变量旧值求出新值，即对一组指令循环执行，最终得到新值作为结果。&lt;br /&gt;
2.在代码中表现为在一个循环内，不断循</summary>
      
    
    
    
    <category term="算法基础" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个结点</title>
    <link href="http://example.com/2023/04/01/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2023/04/01/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2023-03-31T23:28:59.000Z</published>
    <updated>2023-04-03T11:12:01.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230401072816.png" alt="" /><br />用一趟扫描实现：<br />题解：本题是力扣上的题，注意力扣上说的头结点是指首元结点，带有数据域，那么就需要设置一个虚拟头结点来指向首元结点，用双指针遍历，first遍历到结尾时与second正好相差n个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>    ListNode *dummyhead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//设置虚拟头节点</span><br>    dummyhead-&gt;next=head;<br><br>    ListNode *first,*second;<br>    first=second=dummyhead;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        first=first-&gt;next;<span class="hljs-comment">//双指针相差n个，</span><br>    &#125;<br>    <span class="hljs-comment">//此时first与second相差n个，但是当first到结尾时second-&gt;next才是要删除的</span><br>    <span class="hljs-keyword">while</span>(first-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//遍历到结尾</span><br>        first=first-&gt;next;<br>        second=second-&gt;next;<br>    &#125;<br>    second-&gt;next=second-&gt;next-&gt;next;<span class="hljs-comment">//删除second-&gt;next</span><br>    <span class="hljs-keyword">return</span> dummyhead-&gt;next;<span class="hljs-comment">//返回dummyhead-&gt;next，因为有可能首元结点被删去，需要用虚拟头结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china&amp;orderBy=most_votes">题目链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230401072816.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
用一趟扫描实现：&lt;br /&gt;
题解：本题是力扣上的题，注意力扣上说的头</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>一些tips</title>
    <link href="http://example.com/2023/03/29/%E4%B8%80%E4%BA%9BTip/"/>
    <id>http://example.com/2023/03/29/%E4%B8%80%E4%BA%9BTip/</id>
    <published>2023-03-29T13:41:37.000Z</published>
    <updated>2023-04-09T15:17:14.904Z</updated>
    
    <content type="html"><![CDATA[<p>1.定义比较大的数组的时候（例如1e5），要放在全局变量，否则ide会提示段错误<br />2.ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);清除内存，超内存超时时用，大数据集快不少<br />3.力扣上说的头结点意思是首元结点，带有数据域，若要删除首元结点，就需要定义一个虚拟头节点dummynode，别忘了分配空间。（翻译问题？）<br />4.如果从头结点开始遍历，一般让p-&gt;next!=NULL；从首元结点开始遍历就让p!=NULL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.定义比较大的数组的时候（例如1e5），要放在全局变量，否则ide会提示段错误&lt;br /&gt;
2.ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);清除内存，超内存超时时用，大数据集快不少&lt;br /&gt;
3.力扣上说的</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
</feed>
