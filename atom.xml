<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-09T14:57:09.561Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表排序</title>
    <link href="http://example.com/2023/04/08/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/04/08/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/</id>
    <published>2023-04-08T13:47:58.000Z</published>
    <updated>2023-04-09T14:57:09.561Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />链接：<a href="https://leetcode.cn/problems/sort-list/">Sort List</a><br />题意：在时间复杂度为O(nlogn)内，空间复杂度为O(1)内对给定首元结点的链表排序</p><h5 id="归并排序递归实现自顶向下"><a class="markdownIt-Anchor" href="#归并排序递归实现自顶向下"></a> 归并排序（递归实现自顶向下）</h5><p>  归并排序的思想是：将数组拆分成两半，对两半再进行归并排序，最后进行有序合并<br />  时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br />  若要在链表中实现归并排序（递归法），需要以下子方法：</p><ul><li>ListNode *findMid(ListNode *head) 找到链表中点：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双指针找链表中点，偶数个结点时取中间偏左的结点</span><br><span class="hljs-function">ListNode *<span class="hljs-title">findMid</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br><span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;<br><br>ListNode *fast = head-&gt;next;<br>ListNode *slow = head;<br><span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>fast=fast-&gt;next-&gt;next;<br>slow=slow-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ListNode *mergeSort(ListNode *head) 每次找到链表中点，断开，对两边再进行mergeSort</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">mergeSort</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>    <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>        ListNode *mid = <span class="hljs-built_in">findMid</span>(head);<br>        <br>        ListNode *next = mid-&gt;next;<br>        mid-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//断开mid和下一个结点</span><br>        ListNode *left = <span class="hljs-built_in">mergeSort</span>(head);<br>        ListNode *right = <span class="hljs-built_in">mergeSort</span>(next);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(left,right);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>ListNode *merge(ListNode *l1,ListNode *l2) 合并两个升序的链表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(ListNode *l1,ListNode *l2)</span></span>&#123;<br>ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//新建个链表</span><br>ListNode *curr = dummy;<br><span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;<br>curr-&gt;next = l1;<br>l1 = l1-&gt;next;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>curr-&gt;next = l2;<br>l2 = l2-&gt;next;<br>&#125;<br>curr = curr-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">NULL</span>)&#123;<br>curr-&gt;next = l1;<br>&#125;<br><span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">NULL</span>)&#123;<br>curr-&gt;next = l2;<br>&#125;<br><span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最终代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode *<span class="hljs-title">findMid</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;<br><br>        ListNode *fast = head-&gt;next;<br>        ListNode *slow = head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeSort</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>    <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>        ListNode *mid = <span class="hljs-built_in">findMid</span>(head);<br>        <br>        ListNode *next = mid-&gt;next;<br>        mid-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//断开mid和下一个结点</span><br>        ListNode *left = <span class="hljs-built_in">mergeSort</span>(head);<br>        ListNode *right = <span class="hljs-built_in">mergeSort</span>(next);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(left,right);<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(ListNode *l1,ListNode *l2)</span></span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//新建个链表</span><br>        ListNode *curr = dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;<br>                curr-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                curr-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            curr = curr-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">NULL</span>)&#123;<br>            curr-&gt;next = l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">NULL</span>)&#123;<br>            curr-&gt;next = l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(head);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="归并排序迭代实现自底向上"><a class="markdownIt-Anchor" href="#归并排序迭代实现自底向上"></a> 归并排序（迭代实现自底向上）</h5><p>  用迭代实现可以达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的时间复杂度和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>的空间复杂度<br />  想法是先把数组分割成含有1个结点的子链表，分割后从头开始每相邻两个子链表有序合并，然后step增大一倍变为2，再相邻有序合并，step增大一倍变为4，持续合并，最后就成了一个有序链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        <span class="hljs-comment">//获取链表长度</span><br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        ListNode *curr = head;<br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>        len ++;<br>        curr = curr-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//循环遍历</span><br>        <span class="hljs-comment">//外层遍历step，内层处理每step个元素进行一次merge</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> step = <span class="hljs-number">1</span>; step &lt; len; step *= <span class="hljs-number">2</span>)&#123;<br>        ListNode *tail = dummy;<br>        curr = dummy-&gt;next;<br>        <br>        <span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">//left和right是两个相邻的链表，各有step个元素</span><br>        ListNode *left = curr;<br>        ListNode *right = <span class="hljs-built_in">cut</span>(left,step);<br>        <span class="hljs-comment">//巧用cut使成为curr下次开始的点</span><br>        curr = <span class="hljs-built_in">cut</span>(right,step);<br>        <span class="hljs-comment">//tail用来连接链表</span><br>        tail-&gt;next = <span class="hljs-built_in">merge</span>(left,right);<br>        <span class="hljs-keyword">while</span>(tail-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>        tail = tail-&gt;next;<br>        &#125;<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode *<span class="hljs-title">cut</span><span class="hljs-params">(ListNode *from,<span class="hljs-type">int</span> step)</span></span>&#123;<br>    <span class="hljs-comment">//将链表从from开始切掉前step个元素，返回后一个元素（断链</span><br>    step --;<br>    <span class="hljs-keyword">while</span>(from != <span class="hljs-literal">NULL</span> &amp;&amp; step &gt;<span class="hljs-number">0</span>)&#123;<br>    from = from-&gt;next;<br>    step --;<br>    &#125;<br>    <span class="hljs-comment">//包括from，切掉</span><br>    <span class="hljs-keyword">if</span>(from == <span class="hljs-literal">NULL</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//到了尾结点，返回NULL</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    ListNode *next = from-&gt;next;<br>    from-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//断链</span><br>    <span class="hljs-keyword">return</span> next;<span class="hljs-comment">//返回from-&gt;next;</span><br>    &#125;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(ListNode *l1,ListNode *l2)</span></span>&#123;<br>    <span class="hljs-comment">//合并两个有序链表</span><br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//新建个链表</span><br>        ListNode *curr = dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;<br>                curr-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                curr-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            curr = curr-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">NULL</span>)&#123;<br>            curr-&gt;next = l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">NULL</span>)&#123;<br>            curr-&gt;next = l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>参考：<br />  <a href="https://leetcode.cn/problems/sort-list/solution/by-nuo-nuo-zi-4-xrok/">https://leetcode.cn/problems/sort-list/solution/by-nuo-nuo-zi-4-xrok/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
链接：&lt;a href=&quot;https://leetcode.cn/problems/sort-list/&quot;&gt;Sort List&lt;/a&gt;&lt;br /&gt;
题意：在时间复杂度为O(nlogn)内，空间复杂度为O(1)内对给定首元结点的链表排序&lt;/p&gt;
&lt;h5 </summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Vim简单应用</title>
    <link href="http://example.com/2023/04/08/Vim%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2023/04/08/Vim%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</id>
    <published>2023-04-08T09:35:07.000Z</published>
    <updated>2023-04-08T10:50:31.293Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-模式转换"><a class="markdownIt-Anchor" href="#1-模式转换"></a> 1、模式转换</h5><ul><li>命令行模式可以输入<code>i、a</code>等进入编辑模式</li><li>编辑模式点击<code>esc</code>按键进入命令行模式</li><li>命令行模式点击<code>shift+;</code>进入低行模式</li></ul><h5 id="2-编辑模式"><a class="markdownIt-Anchor" href="#2-编辑模式"></a> 2、编辑模式</h5><ul><li>i 从目前光标所在处插入</li><li>I 在当前所在行的第一个非空字符处插入，可用0i替代</li><li>a 从当面光标所在的下一个字符处插入</li><li>A 从当前光标所在行的最后一个字符处开始插入，可以用$a替代</li><li>o 在当前光标所在的下一行处插入新的一行</li><li>O 在当前光标所在的上一行后插入新的一行</li><li>s 删除光标所在字符并开始插入</li><li>S 删除光标所在行并开始插入</li></ul><h5 id="3-低行模式"><a class="markdownIt-Anchor" href="#3-低行模式"></a> 3、低行模式</h5><ul><li>:w 保存文件但不退出vim</li><li>:w file 将修改另外保存到file中，不退出vim</li><li>:!w 强制保存，不推出vim</li><li>:wq 保存文件并退出vim</li><li>:!wq 强制保存文件，并退出vim</li><li>:q 不保存文件，退出vi</li><li>:!q 不保存文件，强制退出vim</li><li>:!e 放弃所有修改，从上次保存文件开始再编辑命令历史</li></ul><h5 id="4-光标移动"><a class="markdownIt-Anchor" href="#4-光标移动"></a> 4、光标移动</h5><ul><li>h 左移、l 右移、j 下移、k 上移</li><li>n+空格 移动到这行该字符后第n个字符</li><li>0 移动到该行最前面字符处</li><li>^ 移动到该行最前面非空字符处</li><li>$ 移动到该行最后</li><li>gg 移动到第一行</li><li>G 移动到最后一行</li><li>ngg 或 nG 移动到第n行</li><li>n 移动到光标下n行</li></ul><h5 id="5-撤回-删除-复制和粘贴"><a class="markdownIt-Anchor" href="#5-撤回-删除-复制和粘贴"></a> 5、撤回、删除、复制和粘贴</h5><ul><li>u 撤销上一步操作</li><li>ctrl+r 恢复上一步被撤销的操作</li><li>. 重复上一步操作</li><li>nx 向后删除n个字符</li><li>X 向前删除一个字符</li><li>ndd 删除光标所在的向下n行</li><li>d1G 删除光标所在到第一行的全部数据</li><li>dG 删除光标到最后一行</li><li>d$ 删除光标到该行最后一个字符</li><li>d0 删除光标到该行第一个字符</li><li>nyy 复制光标所在的向下n行</li><li>y1G 复制光标所在到第一行的全部数据</li><li>yG 复制光标到最后一行</li><li>y$ 复制光标到该行最后一个字符</li><li>y0 复制光标到该行第一个字符</li><li>p 粘贴到光标所在的前一行</li><li>P 粘贴到光标所在的后一行</li><li>J 光标所在行与下一行的数据结合成一行</li></ul><h5 id="6-搜索与替换"><a class="markdownIt-Anchor" href="#6-搜索与替换"></a> 6、搜索与替换</h5><ul><li>/word 光标向下搜索并高亮第一个word</li><li>搜索到后，n 向下搜索下一个word，N 向上反向</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-模式转换&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-模式转换&quot;&gt;&lt;/a&gt; 1、模式转换&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;命令行模式可以输入&lt;code&gt;i、a&lt;/code&gt;等进入编辑模式&lt;/li&gt;
&lt;li&gt;编辑模式点击&lt;code&gt;</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>找出环形链表的入环第一个结点</title>
    <link href="http://example.com/2023/04/07/%E6%89%BE%E5%87%BA%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E7%8E%AF%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2023/04/07/%E6%89%BE%E5%87%BA%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E7%8E%AF%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2023-04-07T13:57:04.000Z</published>
    <updated>2023-04-07T15:11:57.628Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">Linked List Cycle II</a><br />题意：给一个可能有环的链表，若不存在环输出-1，找出入环的第一个结点并返回<br />题解：</p><h5 id="方法一哈希表"><a class="markdownIt-Anchor" href="#方法一哈希表"></a> 方法一：哈希表</h5><p>  因为每个结点是不同的，所以就可以用哈希表存每个结点，一旦遇到重复结点就一定有环<br />  缺点：用时和占用内存都比较大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-comment">//用map也可实现</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        map&lt;ListNode *,<span class="hljs-type">int</span>&gt; visited;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited[head]!=<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            visited[head]++;<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class Solution &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="hljs-comment">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="hljs-comment">        while (head != nullptr) &#123;</span><br><span class="hljs-comment">            if (visited.count(head)) &#123;</span><br><span class="hljs-comment">                return head;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            visited.insert(head);</span><br><span class="hljs-comment">            head = head-&gt;next;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return nullptr;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="双指针法"><a class="markdownIt-Anchor" href="#双指针法"></a> 双指针法</h5><p><img src="https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230407231129.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *slow=head,*fast=head;<br><span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>)&#123;<br>slow=slow-&gt;next;<br><span class="hljs-keyword">if</span>(fast-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>fast=fast-&gt;next-&gt;next;<br><span class="hljs-keyword">if</span>(fast==slow)&#123;<br>ListNode *ptr=head;<br><span class="hljs-keyword">while</span>(ptr!=slow)&#123;<br>ptr=ptr-&gt;next;<br>slow=slow-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> ptr;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
链接：&lt;a href=&quot;https://leetcode.cn/problems/linked-list-cycle-ii/&quot;&gt;Linked List Cycle II&lt;/a&gt;&lt;br /&gt;
题意：给一个可能有环的链表，若不存在环输出-1，找出入环的第</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>对链表插入排序</title>
    <link href="http://example.com/2023/04/05/%E5%AF%B9%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/04/05/%E5%AF%B9%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2023-04-05T14:16:17.000Z</published>
    <updated>2023-04-05T14:52:45.003Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />题目链接：<a href="https://leetcode.cn/problems/insertion-sort-list/">LeetCode 147. Insertion Sort List</a><br />题意：给出首元结点为head的链表，用插入排序来让这个链表有序<br />题解：<br />   插入排序的本质是维护一个有序数组，每次将待排序元素插入到这个数组中。在链表中，只需要有序数组的最后一个元素lastsorted还有待排序元素curr即可，如果curr大于lastsorted就不管，如果curr小于lastsorted的话，就定义一个pre找到待插入位置，先把curr隐去，然后把curr插入过去就行，然后curr=lastsorted-&gt;next即可<br />  这种方法每次只需比较相邻的两个结点大小，如果curr小就遍历一遍前面的元素然后插入，如果大就不管，时间复杂度控制的好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* lastSorted = head;<br>        ListNode* curr = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (lastSorted-&gt;val &lt;= curr-&gt;val) &#123;<br>                lastSorted = lastSorted-&gt;next;<br>            &#125; <br>            <span class="hljs-keyword">else</span> &#123;<br>                ListNode *prev = dummyHead;<br>                <span class="hljs-keyword">while</span> (prev-&gt;next-&gt;val &lt;= curr-&gt;val) &#123;<br>                    prev = prev-&gt;next;<br>                &#125;<br>                lastSorted-&gt;next = curr-&gt;next;<span class="hljs-comment">//隐去curr结点</span><br>                curr-&gt;next = prev-&gt;next;<br>                prev-&gt;next = curr;<span class="hljs-comment">//插入curr结点</span><br>            &#125;<br>            curr = lastSorted-&gt;next;<span class="hljs-comment">//注意curr结点可以重用</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
题目链接：&lt;a href=&quot;https://leetcode.cn/problems/insertion-sort-list/&quot;&gt;LeetCode 147. Insertion Sort List&lt;/a&gt;&lt;br /&gt;
题意：给出首元结点为head的链</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>合并有序链表</title>
    <link href="http://example.com/2023/04/04/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/04/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-04T13:42:25.000Z</published>
    <updated>2023-04-05T14:53:10.899Z</updated>
    
    <content type="html"><![CDATA[<p>难度：简单<br />链接：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a><br />题意：给两个有序链表，将其合并为一个链表并返回首元结点。<br />题解：<br />  假设将list2合并到list1上，先定义虚拟头结点和pre，遍历两个链表，如果list2&gt;list1，就让list1和pre后移，否则list2&lt;=list1将q-&gt;val=list2-&gt;val插入到pre和list之间。遍历到list2结束，如果此时list1有剩余可以不处理，如果list2有剩余，就让pre-&gt;next=list2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode *dummynode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummynode-&gt;next=list1;<span class="hljs-comment">//定义头结点很方便</span><br>        ListNode *pre=dummynode;<br>        <span class="hljs-keyword">while</span>(list1!=<span class="hljs-literal">NULL</span>&amp;&amp;list2!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list2-&gt;val&gt;list1-&gt;val)&#123;<br>                list1=list1-&gt;next;<br>                pre=pre-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ListNode *q=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>                q-&gt;val=list2-&gt;val;<br>                pre-&gt;next=q;<br>                q-&gt;next=list1;<br>                list2=list2-&gt;next; <br>                pre=pre-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list1==<span class="hljs-literal">NULL</span>)&#123;<br>            pre-&gt;next=list2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummynode-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：简单&lt;br /&gt;
链接：&lt;a href=&quot;https://leetcode.cn/problems/merge-two-sorted-lists/&quot;&gt;https://leetcode.cn/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;br</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>重排链表</title>
    <link href="http://example.com/2023/04/03/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/03/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-03T10:14:24.000Z</published>
    <updated>2023-04-07T13:05:09.113Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />题目链接：<a href="https://leetcode.cn/problems/reorder-list/">https://leetcode.cn/problems/reorder-list/</a><br /><img src="https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230403182251.png" alt="" /><br />题解：</p><h5 id="方法一寻找链表中点反转链表合并链表"><a class="markdownIt-Anchor" href="#方法一寻找链表中点反转链表合并链表"></a> 方法一：寻找链表中点+反转链表+合并链表</h5><p>注意到结果正是把链表中点的后半反转后（不包括中点，且偶数结点中中点是中间两个结点的后者），邻一个插入到前半链表，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span><br />代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode *head)</span> <span class="hljs-comment">// 找链表中点</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *first = head, *second = head; <span class="hljs-comment">// 快慢指针</span><br>        <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">NULL</span> &amp;&amp; first-&gt;next != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            first = first-&gt;next-&gt;next;<br>            second = second-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> <span class="hljs-comment">// 迭代法将中点后反转链表</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode *curr = head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ListNode *nextTemp = curr-&gt;next;<br>            curr-&gt;next = prev;<br>            prev = curr;<br>            curr = nextTemp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(ListNode *l1, ListNode *l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *l1_tmp;<br>        ListNode *l2_tmp;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            l1_tmp = l1-&gt;next; <span class="hljs-comment">// 因为要改变结点的next</span><br>            l2_tmp = l2-&gt;next; <span class="hljs-comment">// 所以先用tmp结点存当前结点的next结点</span><br><br>            l1-&gt;next = l2;<br>            l1 = l1_tmp;<br><br>            l2-&gt;next = l1;<br>            l2 = l2_tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode *mid = <span class="hljs-built_in">middleNode</span>(head); <span class="hljs-comment">// 找中点或偶数中点后一个结点</span><br>        ListNode *l1 = head;<br>        ListNode *l2 = mid-&gt;next; <span class="hljs-comment">// 两段链表</span><br>        mid-&gt;next = <span class="hljs-literal">NULL</span>;         <span class="hljs-comment">// 断链</span><br>        l2 = <span class="hljs-built_in">reverseList</span>(l2);     <span class="hljs-comment">// 反转链表</span><br>        <span class="hljs-built_in">mergeList</span>(l1, l2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="方法二线性表"><a class="markdownIt-Anchor" href="#方法二线性表"></a> 方法二：线性表</h5><p>由于链表不支持下标访问，所以无法随机访问链表的元素，可以用vector来当作线性表存链表结点<br />此方法空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，用线性表比较大<br />代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//因为是void型，直接用return结束</span><br>        &#125;<br>        vector&lt;ListNode *&gt; vec;<br>        ListNode *node = head;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(node);<br>            node = node-&gt;next;<span class="hljs-comment">//线性表vec存链表结点</span><br>        &#125;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j)<br>        &#123;<br>            vec[i]-&gt;next = vec[j];<br>            i++;<br>            <span class="hljs-keyword">if</span> (i == j)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            vec[j]-&gt;next = vec[i];<br>            j--;<span class="hljs-comment">//用i++和j--可以找下一个变量和上一个变量</span><br>        &#125;<br>        vec[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
题目链接：&lt;a href=&quot;https://leetcode.cn/problems/reorder-list/&quot;&gt;https://leetcode.cn/problems/reorder-list/&lt;/a&gt;&lt;br /&gt;
&lt;img src=&quot;http</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/2023/04/03/%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/03/%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-03T10:04:57.000Z</published>
    <updated>2023-04-03T11:00:11.854Z</updated>
    
    <content type="html"><![CDATA[<p>示例代码：包括两种方法建立，查找，删除，输出，反转，找中点，交叉合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> n, i;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span><br>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;<br>&#125; *List, node; <span class="hljs-comment">// List和node * 同义</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeadCreatList</span><span class="hljs-params">(List H)</span> <span class="hljs-comment">// 头插法</span></span><br><span class="hljs-function"></span>&#123;<br>    node *p;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        p = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(List));<br>        p-&gt;data = a[i];<br>        p-&gt;next = H-&gt;next;<br>        H-&gt;next = p;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TailCreatList</span><span class="hljs-params">(List H)</span> <span class="hljs-comment">// 尾插法</span></span><br><span class="hljs-function"></span>&#123;<br>    node *p, *r;<br>    r = H; <span class="hljs-comment">// r是尾指针，一直指向最后一个结点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        p = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(List));<br>        p-&gt;data = a[i];<br>        r-&gt;next = p;<br>        r = p;<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// r是最后一个结点，最后一个节点后接空</span><br>&#125;<br><br><span class="hljs-function">node *<span class="hljs-title">Search</span><span class="hljs-params">(List H, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> *w)</span> <span class="hljs-comment">// 查找x在链表中的下标</span></span><br><span class="hljs-function"></span>&#123;<br>    node *p;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    p = H-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;data != x)<br>    &#123;<br>        p = p-&gt;next;<br>        n++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        *w = n + <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为当p-&gt;data==x时就跳出循环，所以加1</span><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        *w = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(List H, <span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 删除为x的数据</span></span><br><span class="hljs-function"></span>&#123;<br>    node *pre, *p, *q;<br>    pre = H;     <span class="hljs-comment">// pre用作前驱</span><br>    p = H-&gt;next; <span class="hljs-comment">// p是当前结点</span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;data == x)<br>        &#123;<br>            q = p; <span class="hljs-comment">// 存结点</span><br>            pre-&gt;next = p-&gt;next;<br>            p = pre-&gt;next;<br>            <span class="hljs-built_in">free</span>(q); <span class="hljs-comment">// 释放结点</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pre = pre-&gt;next;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(List H, <span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 将x插入链表中的第一个大于它的数的前边</span></span><br><span class="hljs-function"></span>&#123;<br>    node *pre, *p, *q;<br>    pre = H; <span class="hljs-comment">// 前驱</span><br>    p = H-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;data &lt; x)<br>    &#123; <span class="hljs-comment">// p停在第一个大于等于x的结点</span><br>        pre = pre-&gt;next;<br>        p = p-&gt;next;<br>    &#125;<br>    q = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(List));<br>    q-&gt;data = x;<br>    pre-&gt;next = q;<br>    q-&gt;next = p;<br>&#125; <span class="hljs-comment">// 若想创建一个有序的链表，就输入每个值然后调用一次Insert就好</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List H)</span></span><br><span class="hljs-function"></span>&#123;<br>    node *p;<br>    p = H-&gt;next;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(node *head)</span> <span class="hljs-comment">// 反转链表，注意这里head是H-&gt;next</span></span><br><span class="hljs-function"></span>&#123;<br>    node *pre, *p;<br>    pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// pre一开始在头结点</span><br>    p = head;   <span class="hljs-comment">// p一开始在首元结点</span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        node *q = p-&gt;next;<br>        p-&gt;next = pre; <span class="hljs-comment">// 改变p点的指针指向</span><br>        pre = p;       <span class="hljs-comment">// 将pre移向下一个结点</span><br>        p = q;         <span class="hljs-comment">// 将p移向下一个结点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function">node *<span class="hljs-title">middleNode</span><span class="hljs-params">(node *head)</span> <span class="hljs-comment">// 找链表中点，注意这里head是H-&gt;next</span></span><br><span class="hljs-function"></span>&#123;<br>    node *first = head, *second = head; <span class="hljs-comment">// 快慢指针</span><br>    <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">NULL</span> &amp;&amp; first-&gt;next != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        first = first-&gt;next-&gt;next;<br>        second = second-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(node *l1, node *l2)</span> <span class="hljs-comment">// 相邻挨个插入</span></span><br><span class="hljs-function"></span>&#123;<br>    node *l1_tmp;<br>    node *l2_tmp;<br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        l1_tmp = l1-&gt;next; <span class="hljs-comment">// 因为要改变结点的next</span><br>        l2_tmp = l2-&gt;next; <span class="hljs-comment">// 所以先用tmp结点存当前结点的next结点</span><br><br>        l1-&gt;next = l2;<br>        l1 = l1_tmp;<br><br>        l2-&gt;next = l1;<br>        l2 = l2_tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    &#125;<br>    List H;<br>    H = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(List));<br>    H-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-built_in">TailCreatList</span>(H);<br>    <span class="hljs-built_in">print</span>(H);<br><br>    <span class="hljs-type">int</span> x, w;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要查找的数据：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    node *z = <span class="hljs-built_in">Search</span>(H, x, &amp;w);<br>    <span class="hljs-keyword">if</span> (z == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不在链表中\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在链表中下标为：%d\n&quot;</span>, w);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的数据：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    <span class="hljs-built_in">Delete</span>(H, x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除后：&quot;</span>);<br>    <span class="hljs-built_in">print</span>(H);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要插入的数据（递增）：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    <span class="hljs-built_in">Insert</span>(H, x);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入后：&quot;</span>);<br>    <span class="hljs-built_in">print</span>(H);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;示例代码：包括两种方法建立，查找，删除，输出，反转，找中点，交叉合并&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>反转部分链表</title>
    <link href="http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-02T14:35:50.000Z</published>
    <updated>2023-04-03T10:17:07.107Z</updated>
    
    <content type="html"><![CDATA[<p>难度：中等<br />题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">https://leetcode.cn/problems/reverse-linked-list-ii/description/</a><br />题意：反转链表的一部分，从left到right，例如[1,2,3,4,5]，left=2，right=4时，解为[1,4,3,2,5]</p><p>题解：反转部分链表可实现，但是反转后如何连接起来需要考虑，即将left-1与right、left与right+1连接起来，需要记录这些结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseLinklist</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>ListNode *pre,*p;<br>        pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pre一开始在头结点</span><br>        p=head;<span class="hljs-comment">//p一开始在首元结点</span><br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            ListNode *q=p-&gt;next;<br>            p-&gt;next=pre;<span class="hljs-comment">//改变p点的指针指向</span><br>            pre=p;<span class="hljs-comment">//将pre移向下一个结点</span><br>            p=q;<span class="hljs-comment">//将p移向下一个结点</span><br>        &#125;<br>        <span class="hljs-comment">//不需要返回，因为结点名称不变</span><br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>ListNode *dummyhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>dummyhead-&gt;next=head;<span class="hljs-comment">//定义虚拟头结点，因为首元结点可能变化</span><br><br>ListNode *pre = dummyhead;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;left<span class="hljs-number">-1</span>;i++)&#123;<br>pre=pre-&gt;next;<span class="hljs-comment">//从头结点走left-1步，定格在left-1结点处</span><br>&#125;<br><br>ListNode *rightNode = pre;<span class="hljs-comment">//接力pre结点，继续往下循环</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left + <span class="hljs-number">1</span> ; i++)&#123;<br>rightNode = rightNode-&gt;next;<span class="hljs-comment">//rightNode循环到right结点</span><br>&#125;<br><br>ListNode *leftNode = pre-&gt;next;<span class="hljs-comment">//指向left</span><br>ListNode *curr = rightNode-&gt;next;<span class="hljs-comment">//指向right+1</span><br><br>pre-&gt;next = <span class="hljs-literal">NULL</span>;<br>rightNode-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//切断链接，截取链表</span><br><br><span class="hljs-built_in">reverseLinklist</span>(leftNode);<span class="hljs-comment">//反转部分链表，各结点位置不变</span><br><br>pre-&gt;next=rightNode;<span class="hljs-comment">//连接前部分</span><br>leftNode-&gt;next=curr;<span class="hljs-comment">//连接后部分</span><br><span class="hljs-keyword">return</span> dummyhead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：中等&lt;br /&gt;
题目链接：&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list-ii/description/&quot;&gt;https://leetcode.cn/problems/reverse-linked-l</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-02T12:47:07.000Z</published>
    <updated>2023-04-03T13:20:57.862Z</updated>
    
    <content type="html"><![CDATA[<p>难度：简单<br />题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a><br />题意：给出一个链表的头结点（首元结点），将该链表反转后，返回反转后的链表<br />题解：</p><h5 id="方法一迭代"><a class="markdownIt-Anchor" href="#方法一迭代"></a> 方法一：迭代</h5><p>直接在遍历链表的过程中原地修改，将当前结点的next指针改为指向前一个节点，然后将p和pre结点都后移，需要借助p的后面结点，所以循环的开始先定义一个q=p-&gt;next;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *pre,*p;<br>        pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pre一开始在头结点</span><br>        p=head;<span class="hljs-comment">//p一开始在首元结点</span><br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            ListNode *q=p-&gt;next;<br>            p-&gt;next=pre;<span class="hljs-comment">//改变p点的指针指向</span><br>            pre=p;<span class="hljs-comment">//将pre移向下一个结点</span><br>            p=q;<span class="hljs-comment">//将p移向下一个结点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<span class="hljs-comment">//遍历到结尾时，pre在最后一个结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="方法二递归"><a class="markdownIt-Anchor" href="#方法二递归"></a> 方法二：递归</h5><p>一直递归到倒数第二个结点，找到结果头结点newhead，然后执行head-&gt;next-&gt;next=null反转最后一个结点和倒数第二个结点的指针，改变head-&gt;next=NULL，然后回退挨个反转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>||head-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//为什么head==NULL?  测试用例有空链表</span><br>            <span class="hljs-keyword">return</span> head;<span class="hljs-comment">//最后返回的是最后一个结点，让newhead等于最后一个结点</span><br>        &#125;<br>        ListNode *newhead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<span class="hljs-comment">//注意，只会执行一次</span><br>        head-&gt;next-&gt;next=head;<span class="hljs-comment">//该行代码第一次执行时是倒数第二个结点，反转指针</span><br>        head-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//提前定义空指针</span><br>        <span class="hljs-keyword">return</span> newhead;<span class="hljs-comment">//一直返回最后的头结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;难度：简单&lt;br /&gt;
题目链接：&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list/description/&quot;&gt;https://leetcode.cn/problems/reverse-linked-list</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>迭代&amp;递归&amp;分治</title>
    <link href="http://example.com/2023/04/02/%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/"/>
    <id>http://example.com/2023/04/02/%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/</id>
    <published>2023-04-02T12:02:43.000Z</published>
    <updated>2023-04-05T10:55:41.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h4><p>1.迭代法称为辗转法，不断的用变量旧值求出新值，即对一组指令循环执行，最终得到新值作为结果。<br />2.在代码中表现为在一个循环内，不断循环最终得到结果。</p><h4 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h4><p>1.定义：递归在数学和计算机科学中指在函数的定义中使用函数自身的方法，还额外指一种通过重复将问题分解为同类子问题而解决问题的方法。基本思想是某个函数直接或间接地调用自身，在求解过程中只需关注如何把原问题划分成符合条件的子问题，不需要过分关注子问题如何解决。<br />2.特征：<strong>结束条件</strong>和<strong>自我调用</strong>，示例概括代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(传入数值)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件)<br>        <span class="hljs-keyword">return</span> 最小子问题解;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(缩小规模);<br>&#125;<br></code></pre></td></tr></table></figure><p>3.缺点：在程序执行中，递归是利用堆栈实现的，每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧，递归层数过多会栈溢出。简单的递归不会消耗空间，比如给出链表头，计算长度的递归代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size_recursion</span><span class="hljs-params">(Node *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">size_recursion</span>(head-&gt;next) + <span class="hljs-number">1</span>;<span class="hljs-comment">//有一个结点加一次1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分治"><a class="markdownIt-Anchor" href="#分治"></a> 分治</h4><p>1.定义：把一个复杂问题分成多个相同或相似的子问题，直到最后子问题都可以直接求解，原问题即子问题的解的合并。分治问题能通过递归算法解决，也能通过非递归算法解决，通常用递归算法<br />2.过程：</p><ul><li>分解原问题为结构相同的子问题</li><li>分解到某个容易求解的边界之后，进行递归求解</li><li>将子问题的解合并成原问题的解<br />3.能解决的问题特征：</li><li>该问题的规模缩小到一定程度就可以容易地解决</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并成该问题的解</li><li>该问题所分解出的各个子问题是<strong>相互独立</strong>的，即子问题之间不包含公共的子问题。(若子问题不相互独立，一般用动态规划)<br />4.分治与递归的区别：递归是一种变成技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体的算法思想。</li></ul><p>参考：<br />  <a href="https://oi.wiki">https://oi.wiki</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;迭代&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#迭代&quot;&gt;&lt;/a&gt; 迭代&lt;/h4&gt;
&lt;p&gt;1.迭代法称为辗转法，不断的用变量旧值求出新值，即对一组指令循环执行，最终得到新值作为结果。&lt;br /&gt;
2.在代码中表现为在一个循环内，不断循</summary>
      
    
    
    
    <category term="算法基础" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个结点</title>
    <link href="http://example.com/2023/04/01/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://example.com/2023/04/01/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2023-03-31T23:28:59.000Z</published>
    <updated>2023-04-03T11:12:01.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230401072816.png" alt="" /><br />用一趟扫描实现：<br />题解：本题是力扣上的题，注意力扣上说的头结点是指首元结点，带有数据域，那么就需要设置一个虚拟头结点来指向首元结点，用双指针遍历，first遍历到结尾时与second正好相差n个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>    ListNode *dummyhead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//设置虚拟头节点</span><br>    dummyhead-&gt;next=head;<br><br>    ListNode *first,*second;<br>    first=second=dummyhead;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        first=first-&gt;next;<span class="hljs-comment">//双指针相差n个，</span><br>    &#125;<br>    <span class="hljs-comment">//此时first与second相差n个，但是当first到结尾时second-&gt;next才是要删除的</span><br>    <span class="hljs-keyword">while</span>(first-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//遍历到结尾</span><br>        first=first-&gt;next;<br>        second=second-&gt;next;<br>    &#125;<br>    second-&gt;next=second-&gt;next-&gt;next;<span class="hljs-comment">//删除second-&gt;next</span><br>    <span class="hljs-keyword">return</span> dummyhead-&gt;next;<span class="hljs-comment">//返回dummyhead-&gt;next，因为有可能首元结点被删去，需要用虚拟头结点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china&amp;orderBy=most_votes">题目链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230401072816.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
用一趟扫描实现：&lt;br /&gt;
题解：本题是力扣上的题，注意力扣上说的头</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>一些tips</title>
    <link href="http://example.com/2023/03/29/%E4%B8%80%E4%BA%9BTip/"/>
    <id>http://example.com/2023/03/29/%E4%B8%80%E4%BA%9BTip/</id>
    <published>2023-03-29T13:41:37.000Z</published>
    <updated>2023-04-07T13:09:39.098Z</updated>
    
    <content type="html"><![CDATA[<p>1.定义比较大的数组的时候（例如1e5），要放在全局变量，否则ide会提示段错误<br />2.ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);清除内存，超内存超时时用，大数据集快不少<br />3.力扣上说的头结点意思是首元结点，带有数据域，若要删除首元结点，就需要定义一个虚拟头节点dummynode，别忘了分配空间。（翻译问题？）<br />4.如果从头结点开始遍历，一般让p-&gt;next!=NULL；从首元结点开始遍历就让p!=NULL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.定义比较大的数组的时候（例如1e5），要放在全局变量，否则ide会提示段错误&lt;br /&gt;
2.ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);清除内存，超内存超时时用，大数据集快不少&lt;br /&gt;
3.力扣上说的</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://example.com/2023/03/24/%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/03/24/%E6%8E%92%E5%BA%8F/</id>
    <published>2023-03-24T12:33:17.000Z</published>
    <updated>2023-04-08T14:58:39.695Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/image-20230324210604464.png" alt="image-20230324210604464" /></p><h4 id="排序相关stl"><a class="markdownIt-Anchor" href="#排序相关stl"></a> 排序相关STL</h4><h5 id="1stdsort"><a class="markdownIt-Anchor" href="#1stdsort"></a> 1.std::sort</h5><p>1.两种用法：sort(a,a+n)或者sort(a,a+n,cmp);<br />2.未指定cmp函数时，sort是从小到大的顺序排列，c++标准以及以后的标准要求最坏时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br />3.使用cmp函数的示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ab</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>&#125; p[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ab x, ab y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x.a == y.a)<br>    &#123;<br>        <span class="hljs-keyword">return</span> x.b &lt; y.b; <span class="hljs-comment">// 从小到大顺序</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> x.a &lt; y.a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cin &gt;&gt; p[i].a &gt;&gt; p[i].b;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(p, p + n, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; p[i].a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p[i].b &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">5 4</span><br><span class="hljs-comment">4 4</span><br><span class="hljs-comment">3 4</span><br><span class="hljs-comment">3 5</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="2stable_sort"><a class="markdownIt-Anchor" href="#2stable_sort"></a> 2.stable_sort</h5><p>1、用法和sort一样，不过是稳定排序</p><h5 id="3nth_element"><a class="markdownIt-Anchor" href="#3nth_element"></a> 3.nth_element</h5><p>1、nth_element(a,a+k,a+n);，使第n小的数在第k位就位，然后输出a[k]即可</p><h4 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h4><p>1、原理：每次循环，找出 第i小的元素，即剩下最小的元素，然后和数组中第i个位置上的元素交换。<br />2、稳定性：由于需要交换元素，是一种不稳定的排序算法<br />3、时间复杂度：最优、平均、最坏时间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><br />4、代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> ith = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[ith])<br>            &#123;<br>                ith = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(a[i], a[ith]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h4><p>1、原理：每次检查相邻元素，如果相邻元素满足给定的顺序交换条件，就将相邻的两个元素交换，每次循环，必有一个最值靠边，所以最多扫描n-1遍数组<br />2、稳定性：冒泡排序是一种稳定的排序算法<br />3、时间复杂度：完全有序时，只需遍历一遍数组，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>；最坏情况下，冒泡排序要执行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mrow><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.01em;"></span><span class="strut bottom" style="height:1.355em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.485em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>次交换，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>；平均时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>。<br />4、代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 假设数组的大小是 n + 1，冒泡排序从数组下标 1 开始</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (flag)<br>    &#123;<br>        flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 判断若完美数组直接退出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[i + <span class="hljs-number">1</span>])<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-type">int</span> t = a[i];<br>                a[i] = a[i + <span class="hljs-number">1</span>];<br>                a[i + <span class="hljs-number">1</span>] = t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>或者：<br><span class="hljs-comment">// 假设数组的大小是len，冒泡排序从数组下标0开始</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h4><p>1、原理：将原数组划分为待排序部分和已排序部分，每次从待排序不放呢选择一个元素插入到已排序中，最后形成已排序数组<br />2、稳定性：插入排序是一种稳定的排序算法<br />3、时间复杂度：<strong>最优</strong>时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，<strong>最坏</strong>和<strong>平均</strong>时间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><br />4、代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 从小到大，已排序好的在前面</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> key = arr[i];<br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) <span class="hljs-comment">// 每次循环将a[i]插入a[0]到a[i-1]的有序数组中</span><br>        &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j]; <span class="hljs-comment">// 给arr[i]让位置</span><br>            j--;<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h4><p>1、原理：使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数，然后根据数组C将A中的元素排到正确的位置<br />2、步骤：（1）计算每个数出现几次（2）求出每个数出现次数的前缀和（3）利用出现次数的前缀和，从右至左计算每个数的排名<br />3、稳定性：计数排序是一种稳定的排序算法<br />4、时间复杂度：均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>w</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span></span>代表排序数据的值域大小<br />5、代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W = <span class="hljs-number">100010</span>;<br><span class="hljs-comment">// 注意，此算法有局限性，必须知道值域w，数组下标为1~n</span><br><span class="hljs-type">int</span> n, w, a[N], cnt[W], b[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cnt[a[i]]++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= w; i++)<br>        cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) <span class="hljs-comment">// 逆序为了保持稳定性</span><br>    &#123;<br>        b[cnt[a[i]]] = a[i];<br>        cnt[a[i]]--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h4><p>1、定义：基数排序是一种非比较型的排序算法，将待排序的数组中的每个元素拆分为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>个关键字，逐一对各个关键字排序后完成对所有元素的排序。<br />2、关键字元素的比较：从第一关键字一直比较到最后一个关键字，如果按顺序某个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&gt;</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i&gt;b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">&gt;</span><span class="mord"><span class="mord mathit">b</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a&gt;b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">&gt;</span><span class="mord mathit">b</span></span></span></span>。对于自然数，将自然数按个位对齐后往高位补0，则一个数字从左往右第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span>位数就可以作为第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span>关键字；对于字符串，从左往右第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span>个字符就是第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span>关键字。<br />3、MSD基数排序：<br />（1）从第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>关键字到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>关键字顺序进行比较<br />（2）需要借助一种<strong>稳定算法</strong>完成内层对关键字的排序，通常用计数排序来完成<br />4、LSD基数排序：<br />（1）从第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>关键字到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>关键字顺序比较<br />（2）同样借助计数排序<br />5、稳定性：都是稳定的排序算法<br />6、时间复杂度：比基于比较的排序算法（比如快速排序）更快，但需要额外的内存空间，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>k</mi><mi>n</mi><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>w</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">O(kn+\sum\limits_{i=1}^k w_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.5361130000000003em;"></span><span class="strut bottom" style="height:2.513782em;vertical-align:-0.9776689999999999em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mop op-limits"><span class="vlist"><span style="top:0.8776689999999999em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.000005000000000088267em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol small-op mop">∑</span></span></span><span style="top:-0.9500050000000002em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><br />7、空间复杂度：MSD与LSD基数排序的空间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p><h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h4><p>1、原理：通过分治的方法来将一个数组排序,以下为三个过程</p><ul><li>将数列划分为两部分(保证相对大小关系)</li><li>递归到两个子序列中分别进行快速排序</li><li>不用合并,因为此时数列已经完全有序<br />2、和归并排序的区别：在分成前后两份的时候，会保证前数组最大比后数组最小的值更小，即有相对大小关系，一般随机取一个数来当作两个子数列的分界。<br />3、步骤：维护前后两个指针p和q，一次考虑当前的数是否放在了应该放的位置（前还是后）。如果当前的数没放对，就交换两个指针所指元素，直到两指针相遇。<br />4、稳定性：快速排序是一种不稳定的排序算法<br />5、时间复杂度：最优和平均时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，最欢时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><br />6、示例代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span><br>            i++;<br>        <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span><br>            j--;<br>        <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j)<br>            <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h4><p>1、定义：归并排序是高效的基于比较的稳定排序算法<br />2、性质；归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优与平均情况下均为$ \Theta (n \log n)，空间复杂度为 \Theta (n) 3、过程：将a[i]和b[j]合并为一个有序的数组c[k]，从左往右枚举a[i]和b[j]，找出最小的值放入c[k]；重复上述过程直到a[j]和b[j]有一个为空，将另一个数组剩下的元素放入c[k]。为保证排序的稳定性，判断条件是a[i]&lt;=b[j]而不是a[i]&lt;b[j]$<br />4、示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j])<br>            tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span><br>            tmp[k++] = q[j++];<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid)<br>        tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r)<br>        tmp[k++] = q[j++];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)<br>        q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h4><p><img src="https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/20230330213156.png" alt="" /><br />1、定义：利用二叉堆这种数据结构来进行排序，本质是完全二叉树<br />2、过程：首先建立小根堆，根节点即最小值，取出最小值后，根节点与最后一个结点交换，即减少一个元素，之后再取根结点作为第二小元素，依次循环<br />3、稳定性：同选择排序一样，由于其中交换位置的操作，所以是不稳定的排序算法<br />4、时间复杂度：均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span><br />5、空间复杂度：由于可以在输入数组上建立堆，所以这是一个原地算法<br />6、代码示例：（<a href="https://www.acwing.com/problem/content/description/840/">acwing 838堆排序</a>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], siz;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u; <span class="hljs-comment">// 存储三个结点中存在的最小的结点的下标</span><br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= siz &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t])<br>        t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= siz &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t])<br>        t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[u], h[t]);<br>        <span class="hljs-built_in">down</span>(t); <span class="hljs-comment">// 交换数值后，继续下沉</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i]);<br>    siz = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-comment">// 从一半开始下沉，时间复杂度减小为O(n)</span><br>    &#123;<br>        <span class="hljs-built_in">down</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, h[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出最小值</span><br>        h[<span class="hljs-number">1</span>] = h[siz];       <span class="hljs-comment">// 删除最小值，将其替换为最后一个值</span><br>        siz--;<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h4><p>1、定义：桶排序适用于给定区间，数据值域较大但分布比较均匀的情况<br />2、过程：</p><ul><li>将区间分为n个等分的空桶，确定每个区间大小</li><li>遍历序列，并将元素一个个放入对应的桶中（按照大小加入有序的对应区间）</li><li>对每个不是空的桶进行排序</li><li>从不是空的桶里把元素再放回原来的序列中</li></ul><p>3、稳定性：如果使用稳定的内层排序，并且将元素插入桶中时不改变元素间的相对顺序，那么就是一种稳定的排序算法。<br />4、平均时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，最坏时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><br />5、代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 巧妙之处在于将数据插入到区间时就已经整体有序了，接着区间内排序再插回数组就可以了</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n, w, a[N]; <span class="hljs-comment">// w为最大值，n为元素个数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; bucket[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A)</span> <span class="hljs-comment">// 插入排序在小区间性能优秀</span></span><br><span class="hljs-function"></span>&#123;                                   <span class="hljs-comment">// 此时A是bucket[i]对应的数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; A.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> key = A[i];<br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] &gt; key)<br>        &#123;<br>            A[j + <span class="hljs-number">1</span>] = A[j];<br>            --j;<br>        &#125;<br>        A[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucket_sort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> bucket_size = w / n + <span class="hljs-number">1</span>; <span class="hljs-comment">// 确定每个桶区间大小</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        bucket[i].<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        bucket[a[i] / bucket_size].<span class="hljs-built_in">push_back</span>(a[i]); <span class="hljs-comment">// 将数加入对应区间</span><br>    &#125;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-built_in">insertion_sort</span>(bucket[i]); <span class="hljs-comment">// 对区间排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; bucket[i].<span class="hljs-built_in">size</span>(); ++j)<br>        &#123;<br>            a[++p] = bucket[i][j];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">bucket_sort</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span>)<br>            cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">10 10</span><br><span class="hljs-comment">2 3 1 8 5 10 4 3 9 6</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h4><p>1、定义：希尔排序也成为缩小增量排序法，是插入排序的一种改进版本，希尔排序以它的发明者希尔命名<br />2、过程：</p><ul><li>将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同）</li><li>将这些子序列进行插入排序</li><li>减小每个子序列中元素之间的间距（缩小增量），重复上述过程直至间距减少为1<br />3、时间复杂度：最优时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，平均时间复杂度和最坏时间复杂度与间距序列的选取（就是间距如何减小到 1）有关，比如「间距每次除以 3」的希尔排序的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^{3/2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8879999999999999em;"></span><span class="strut bottom" style="height:1.138em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>。已知最好的最坏时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msup><mi>log</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。<br />4、空间复杂度：希尔排序的空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span><br />5、代码示例：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-type">int</span> length)</span><br>&#123;<br>    <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (h &lt; length / <span class="hljs-number">3</span>)<br>    &#123;<br>        h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>; <span class="hljs-comment">// h为1,4,13</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) <span class="hljs-comment">// 最后h等于1的时候再进行一个插入排序就ok了</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h; i &lt; length; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= h &amp;&amp; <span class="hljs-built_in">array</span>[j] &lt; <span class="hljs-built_in">array</span>[j - h]; j = j - h)<br>            &#123; <span class="hljs-comment">// 插入排序是单向和相邻的比较</span><br>                swap(<span class="hljs-built_in">array</span>[j], <span class="hljs-built_in">array</span>[j - h]);<br>            &#125;<br>        &#125;<br>        h = h / <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, n = <span class="hljs-number">5</span>;<br>    shell_sort(a, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<br />  <a href="https://oi.wiki/">https://oi.wiki/</a><br />  <a href="https://www.acwing.com">https://www.acwing.com</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/remnantsaint/hexoImage@main/image-20230324210604464.png&quot; alt=&quot;image-20230324210604464&quot; /&gt;&lt;/p&gt;
&lt;h4 i</summary>
      
    
    
    
    <category term="算法基础" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>回文数</title>
    <link href="http://example.com/2023/03/22/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://example.com/2023/03/22/%E5%9B%9E%E6%96%87%E6%95%B0/</id>
    <published>2023-03-22T09:46:13.000Z</published>
    <updated>2023-03-24T14:06:34.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="noip1999-普及组-回文数"><a class="markdownIt-Anchor" href="#noip1999-普及组-回文数"></a> [NOIP1999 普及组] 回文数</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。</p><p>例如：给定一个十进制数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>6</mn></mrow><annotation encoding="application/x-tex">56</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">6</span></span></span></span>，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>6</mn></mrow><annotation encoding="application/x-tex">56</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">6</span></span></span></span> 加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mn>5</mn></mrow><annotation encoding="application/x-tex">65</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span><span class="mord mathrm">5</span></span></span></span>（即把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>6</mn></mrow><annotation encoding="application/x-tex">56</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">6</span></span></span></span> 从右向左读），得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>2</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">121</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathrm">1</span></span></span></span> 是一个回文数。</p><p>又如：对于十进制数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>7</mn></mrow><annotation encoding="application/x-tex">87</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">7</span></span></span></span>：</p><p>STEP1：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>7</mn><mo>+</mo><mn>7</mn><mn>8</mn><mo>=</mo><mn>1</mn><mn>6</mn><mn>5</mn></mrow><annotation encoding="application/x-tex">87+78=165</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">7</span><span class="mbin">+</span><span class="mord mathrm">7</span><span class="mord mathrm">8</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">6</span><span class="mord mathrm">5</span></span></span></span><br />STEP2：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>6</mn><mn>5</mn><mo>+</mo><mn>5</mn><mn>6</mn><mn>1</mn><mo>=</mo><mn>7</mn><mn>2</mn><mn>6</mn></mrow><annotation encoding="application/x-tex">165+561=726</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">6</span><span class="mord mathrm">5</span><span class="mbin">+</span><span class="mord mathrm">5</span><span class="mord mathrm">6</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord mathrm">7</span><span class="mord mathrm">2</span><span class="mord mathrm">6</span></span></span></span><br />STEP3：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn><mn>2</mn><mn>6</mn><mo>+</mo><mn>6</mn><mn>2</mn><mn>7</mn><mo>=</mo><mn>1</mn><mn>3</mn><mn>5</mn><mn>3</mn></mrow><annotation encoding="application/x-tex">726+627=1353</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">7</span><span class="mord mathrm">2</span><span class="mord mathrm">6</span><span class="mbin">+</span><span class="mord mathrm">6</span><span class="mord mathrm">2</span><span class="mord mathrm">7</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">3</span><span class="mord mathrm">5</span><span class="mord mathrm">3</span></span></span></span><br />STEP4：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>3</mn><mn>5</mn><mn>3</mn><mo>+</mo><mn>3</mn><mn>5</mn><mn>3</mn><mn>1</mn><mo>=</mo><mn>4</mn><mn>8</mn><mn>8</mn><mn>4</mn></mrow><annotation encoding="application/x-tex">1353+3531=4884</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">3</span><span class="mord mathrm">5</span><span class="mord mathrm">3</span><span class="mbin">+</span><span class="mord mathrm">3</span><span class="mord mathrm">5</span><span class="mord mathrm">3</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord mathrm">4</span><span class="mord mathrm">8</span><span class="mord mathrm">8</span><span class="mord mathrm">4</span></span></span></span></p><p>在这里的一步是指进行了一次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> 进制的加法，上例最少用了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span></span></span></span> 步得到回文数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mn>8</mn><mn>8</mn><mn>4</mn></mrow><annotation encoding="application/x-tex">4884</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span><span class="mord mathrm">8</span><span class="mord mathrm">8</span><span class="mord mathrm">4</span></span></span></span>。</p><p>写一个程序，给定一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">2 \le N \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mrel">≤</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>1</mn><mn>6</mn></mrow><annotation encoding="application/x-tex">N=16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">6</span></span></span></span>）进制数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span> 位之内），求最少经过几步可以得到回文数。如果在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">0</span></span></span></span> 步以内（包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">0</span></span></span></span> 步）不可能得到回文数，则输出 <code>Impossible!</code>。</p><h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2><p>两行，分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span>。</p><h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2><p>如果能在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">0</span></span></span></span> 步以内得到回文数，输出格式形如 <code>STEP=ans</code>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mtext></mrow><annotation encoding="application/x-tex">\text{ans}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm">s</span></span></span></span></span> 为最少得到回文数的步数。</p><p>否则输出 <code>Impossible!</code>。</p><h2 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1"></a> 样例 #1</h2><h3 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">10</span><br><span class="hljs-number">87</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">STEP=<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2><p>本题用到了高精度加，需要注意的是不需要转换进制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n, q[N], l, w[N], ans;<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-comment">// 得到每位的十进制</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>        &#123;<br>            j++; <span class="hljs-comment">// 数组q第一位有效是q[1]</span><br>            q[j] = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            j++;<br>            q[j] = s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span> <span class="hljs-comment">// 判断是否为回文数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ln = l;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = l;<br>    <span class="hljs-keyword">while</span> (ln--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ln &lt; l / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (a[i] != a[j])<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 不是回文返回0</span><br>        &#125;<br>        i++;<br>        j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">turn</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span> <span class="hljs-comment">// 翻转数组</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &gt;= <span class="hljs-number">1</span>; i--)<br>    &#123;<br>        w[++j] = a[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> b[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l; i++)<br>    &#123;<br>        a[i] = a[i] + b[i];<br>        a[i + <span class="hljs-number">1</span>] = a[i + <span class="hljs-number">1</span>] + a[i] / n; <span class="hljs-comment">// 进位</span><br>        a[i] = a[i] % n;                <span class="hljs-comment">// 注意，此处%n和/n表示所有进制通用</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[l + <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">// 最高位进位了</span><br>        l++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; s;<br>    <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// 把s字符串存入q数组中</span><br>    l = s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">judge</span>(q)) <span class="hljs-comment">// 不是回文继续循环</span><br>    &#123;<br>        <span class="hljs-built_in">turn</span>(q);<br>        <span class="hljs-built_in">add</span>(q, w);<br>        ans++;<br>        <span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-number">30</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-number">30</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Impossible!&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;STEP=&quot;</span> &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;noip1999-普及组-回文数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#noip1999-普及组-回文数&quot;&gt;&lt;/a&gt; [NOIP1999 普及组] 回文数&lt;/h1&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a class=&quot;markdow</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="高精度" scheme="http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用archlinux参考文章</title>
    <link href="http://example.com/2023/01/08/%E4%BD%BF%E7%94%A8archlinux%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2023/01/08/%E4%BD%BF%E7%94%A8archlinux%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0/</id>
    <published>2023-01-08T04:18:22.000Z</published>
    <updated>2023-03-24T12:42:29.654Z</updated>
    
    <content type="html"><![CDATA[<p>arch wiki：<a href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97">https://wiki.archlinuxcn.org/wiki/安装指南</a><br />安装参考：<a href="https://blog.linioi.com/posts/18/">https://blog.linioi.com/posts/18/</a><br />连网参考：</p><ul><li><a href="https://blog.csdn.net/bangren3304/article/details/101078641">https://blog.csdn.net/bangren3304/article/details/101078641</a></li><li><a href="https://blog.csdn.net/ZHISHAN_IoT/article/details/123453619">https://blog.csdn.net/ZHISHAN_IoT/article/details/123453619</a></li></ul><p>字体参考：<a href="https://blog.csdn.net/m0_47627464/article/details/113790309">https://blog.csdn.net/m0_47627464/article/details/113790309</a></p><p>使用中出现的问题：</p><ul><li>使用fcitx5时，用ctrl+shift切换输入法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;arch wiki：&lt;a href=&quot;https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97&quot;&gt;https://wiki.archlinuxcn.org/wiki/安装指南&lt;/a&gt;&lt;br </summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo初建站</title>
    <link href="http://example.com/2022/12/29/hexo%E5%88%9D%E5%BB%BA%E7%AB%99/"/>
    <id>http://example.com/2022/12/29/hexo%E5%88%9D%E5%BB%BA%E7%AB%99/</id>
    <published>2022-12-29T08:30:48.000Z</published>
    <updated>2023-04-08T22:48:38.471Z</updated>
    
    <content type="html"><![CDATA[<p>1.下载安装git与node.js</p><p>2.配置nodejs环境(略)</p><p>3.连接github ：<br /><code>git config --global user.name &quot;GitHub用户名&quot;</code><br /><code>git config --global user.email &quot;GitHub邮箱&quot;</code></p><p>4.创建密匙<code>ssh-keygen -t rsa -C &quot;Github邮箱&quot;</code>，在github中添加密匙</p><p>5.验证连接<code>ssh -T git@github.com</code></p><p>6.创建<code>username.github.io</code>（username为github用户名）</p><p>7.在本地创建hexo文件夹，进入文件夹内，右键git bash here</p><p>8.使用<code>npm install</code>将按照package.json安装所需要的组件放在生成的node_modules文件夹中</p><p>9.安装hexo：<br />npm install -g hexo-cli<br />hexo init<br />git init<br />hexo g #生成页面<br />hexo s #本地预览，用loacalhost:4000<br />npm install hexo-deployer-git --save<br />修改<code>\_config.yml</code>文件末尾部分为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">deploy:  <br>  type: git  <br>  repository: git@github.com:用户名/用户名.github.io.git  <br>  branch: main  <br></code></pre></td></tr></table></figure><p>注意：main是主分支，以前主分支是master</p><p>10.上传hexo：<br />hexo clean<br />hexo d -g<br />hexo new name创建文章<br />在github.io页面就能显示hexo了</p><p>11.绑定域名：<br />解析域名到github.io的ip地址上<br />在hexo根目录的source目录下创建CNAME文件，内容为<code>http://域名</code><br />重新上传网页</p><p>11.域名开启https<br />在仓库的settings中pages栏目找到Enforce Https勾选</p><p>12.个人博客主题配置（略）</p><p>13.github+picgo+typora使用图床（用typora没有vscode的报错黄色提醒真好 <code>\^o^/~</code>）（注意用shift+enter换行同段写字，类似于wordpress）</p><p>14.解决数学公式渲染问题，用kramed，完美解决之前的分数线消失、下标上标显示位置不正确、重复出现公式等问题</p><p>15.pure主题的代码不好看，可以修改一下</p><p>参考：<br />  <a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a><br />  <a href="https://zhuanlan.zhihu.com/p/489236769">github+picgo+typora</a><br />  <a href="https://www.jianshu.com/p/93c2a7862244">kramed代替marked</a><br />  <a href="http://blog.iwwee.com/posts/hexo-optimize.html#%E4%B8%BA%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A2%9E%E5%8A%A0%E5%A4%8D%E5%88%B6%E6%8C%89%E9%92%AE">优化pure、修改pure代码和增加复制</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.下载安装git与node.js&lt;/p&gt;
&lt;p&gt;2.配置nodejs环境(略)&lt;/p&gt;
&lt;p&gt;3.连接github ：&lt;br /&gt;
&lt;code&gt;git config --global user.name &amp;quot;GitHub用户名&amp;quot;&lt;/code&gt;&lt;br /&gt;</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>markdown的基础用法</title>
    <link href="http://example.com/2022/12/29/markdown%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2022/12/29/markdown%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</id>
    <published>2022-12-29T08:27:29.000Z</published>
    <updated>2023-03-31T12:43:09.325Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1标题"><a class="markdownIt-Anchor" href="#1标题"></a> 1.标题</h4><p> 使用#后接空格表示标题,一共六级<br /> 例如 # 一级标题 ## 二级标题</p><h4 id="2字体"><a class="markdownIt-Anchor" href="#2字体"></a> 2.字体</h4><p> (1)斜体：<code>*123*</code>或者<code>_123_</code> 效果为 <em>123</em><br /> (2)粗体：<code>**123**</code>或者<code>__123__</code> 效果为 <strong>123</strong><br /> (3)粗斜体：<code>***123***</code>或者<code>___123___</code> 效果为 <em><strong>123</strong></em><br /> (4)删除线：<code>~~123~~</code>效果为<s>123</s><br /> (5)下划线：<code>&lt;u&gt;123&lt;/u&gt;</code>效果为 <u>123</u></p><h4 id="3分割线"><a class="markdownIt-Anchor" href="#3分割线"></a> 3.分割线</h4><p>  用三个以上的星号、减号来建立一个分割线，行内不能有其他东西，也可以在型号活减号中插入空格，即<code>***</code>或<code>---</code><br />示例：</p><hr /><h4 id="4列表"><a class="markdownIt-Anchor" href="#4列表"></a> 4.列表</h4><p> markdown支持有序列表和无序列表<br />  (1)无序列表用*或+或-在一行的开头，后接空格，示例：</p><ul><li>123<br />  (2)有序列表用数字和.在一行的开头，后接空格，示例：</li></ul><ol><li>123</li></ol><h4 id="5特殊符号"><a class="markdownIt-Anchor" href="#5特殊符号"></a> 5.特殊符号</h4><p> 使用<code>&amp;emsp;</code>来在markdown中创建全角空格</p><h4 id="6区块"><a class="markdownIt-Anchor" href="#6区块"></a> 6.区块</h4><p> 区块引用是再段落开头使用&gt;符号，后面紧跟空格符号，既可以引用嵌套，也可以和列表互相嵌套。列表嵌套在引用中用&gt; *，引用嵌套在列表中用*后每一行一个&gt;，例如；</p><blockquote><p>123</p></blockquote><h4 id="7代码"><a class="markdownIt-Anchor" href="#7代码"></a> 7.代码</h4><p> (1)段落上的一段代码可以用单反引号`包起来，例如：`printf()`，显示为<code>printf()</code>，在markdown文档中用来把演示代码圈起来很方便。<br /> (2)区块代码通常用三个反引号包起来，并指定一种语言，```c++ 123 ```，显示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h4 id="8链接"><a class="markdownIt-Anchor" href="#8链接"></a> 8.链接</h4><p> (1)直接用&lt;&gt;将链接地址包起来，例如<code>&lt;https://remsait.com&gt;</code><br /> (2)若需要自定义链接名称，用<code>[连接名称](链接地址)</code>来表示，例如：<code>[我的博客](https://remnantsaint.github.io)</code>，注意用<code>https://</code><br /> (3)高级链接：用1作为变量：<code>[Goole][1]</code>，最后在结尾加上<code>[1]: http://www.goole.com/</code></p><h4 id="9图片"><a class="markdownIt-Anchor" href="#9图片"></a> 9.图片</h4><p>(1)用法：<code>![alt 属性文本](图片地址 &quot;可选标题&quot;)</code>，其中属性文本是替代文字，可选标题可以没有。高级用法和链接一样。<br />(2)markdown无法指定图片的高度和宽度，可以用普通的<code>&lt;img&gt;</code>标签：<code>&lt;img decoding=&quot;async&quot; src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;</code></p><h4 id="10表格"><a class="markdownIt-Anchor" href="#10表格"></a> 10.表格</h4><p> markdown制作表格用|来分隔不同的单元格，使用-分隔表头和其他行，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">|  表头   | 表头  |<br>|  ----  | ----  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br></code></pre></td></tr></table></figure><p>显示为：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr><tr><td>在第二行的<code>---</code>中，使用<code>-:</code>表示居右对齐、使用<code>:-</code>表示居左对齐、使用<code>:-:</code>表示居中对齐</td><td></td></tr></tbody></table><h4 id="11数学公式"><a class="markdownIt-Anchor" href="#11数学公式"></a> 11.数学公式</h4><p>  1.上标<code>$O(n^2)$</code>，效果为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><br />  2.下标<code>$O(n_2)$</code>，效果为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msub><mi>n</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><br />  3.分数<code>$\frac&#123;分子&#125;&#123;分母&#125;$</code>，效果为\frac{分子}{分母}<br />  4.累加<code>$\sum\limits_&#123;i=1&#125;^k a_i$</code>，效果为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^k a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.5361130000000003em;"></span><span class="strut bottom" style="height:2.513782em;vertical-align:-0.9776689999999999em;"></span><span class="base textstyle uncramped"><span class="mop op-limits"><span class="vlist"><span style="top:0.8776689999999999em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.000005000000000088267em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol small-op mop">∑</span></span></span><span style="top:-0.9500050000000002em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><br />  5.约等于<code>$\approx$</code>，效果为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.48312em;"></span><span class="strut bottom" style="height:0.48312em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mrel">≈</span></span></span></span></p><h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4><p> (1)在使用vscode编辑markdown时，因为用了markdownlint插件导致html标签有黄色波浪线，右键选择命令面板，打开用户设置，输入以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-string">&quot;markdownlint.config&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;default&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;MD033&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;allowed_elements&quot;</span>: [<br>      <span class="hljs-string">&quot;font&quot;</span>,<br>      <span class="hljs-string">&quot;li&quot;</span>,<br>      <span class="hljs-string">&quot;table&quot;</span>,<br>      <span class="hljs-string">&quot;tr&quot;</span>,<br>      <span class="hljs-string">&quot;td&quot;</span>,<br>      <span class="hljs-string">&quot;u&quot;</span> <span class="hljs-comment">//自己添加html标签</span><br>    ]<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p> (2)我的package.json文件中hexo-renderer-marked渲染器版本是&quot;^6.0.0&quot;，在浏览器中不会把<code>&amp;emsp;</code>变为空格，会显示<code>&amp;emsp;</code>文本样式，通过更改渲染器来解决问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">npm un hexo-renderer-marked --save<br>npm i hexo-renderer-markdown-it --save<br>npm i markdown-it-checkbox<br>npm i markdown-it-imsize<br>npm i markdown-it-expandable<br>（该解决方法已改变，更改为kramed，具体看hexo初建站文章中数学公式问题）<br></code></pre></td></tr></table></figure><p>参考：<br /> <a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a><br /> <a href="https://blog.csdn.net/qq_42951560/article/details/123596899">https://blog.csdn.net/qq_42951560/article/details/123596899</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1标题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1标题&quot;&gt;&lt;/a&gt; 1.标题&lt;/h4&gt;
&lt;p&gt; 使用#后接空格表示标题,一共六级&lt;br /&gt;
 例如 # 一级标题 ## 二级标题&lt;/p&gt;
&lt;h4 id=&quot;2字体&quot;&gt;&lt;a class</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
</feed>
