{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-03-23T12:54:17.460Z","updated":"2022-12-27T12:12:23.418Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-03-23T12:54:21.877Z","updated":"2022-12-27T12:12:23.420Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-12-27T12:20:09.587Z","updated":"2022-12-27T12:12:23.420Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-03-23T12:54:35.591Z","updated":"2022-12-27T12:12:23.420Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-03-25T06:48:56.265Z","updated":"2023-03-25T06:48:56.265Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"我名叫小刘，20岁，在黑龙江省。未婚，我在东北林业大学上学。我不抽烟，不喝酒，晚上11点睡，每天要睡足8个小时。睡前我一定刷b站，闭上眼马上熟睡。一觉到天亮，绝不把疲劳和压力留到第二天，医生都说我很正常！"},{"title":"友情链接","date":"2022-12-27T13:32:25.801Z","updated":"2022-12-27T12:12:23.420Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-03-23T12:54:38.726Z","updated":"2022-12-27T12:12:23.421Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"linux常用","slug":"linux常用","date":"2023-05-02T03:09:33.000Z","updated":"2023-05-02T03:22:49.864Z","comments":true,"path":"2023/05/02/linux常用/","link":"","permalink":"http://example.com/2023/05/02/linux%E5%B8%B8%E7%94%A8/","excerpt":"","text":"du -sh查看文件夹大小；du -sh *查看该文件夹下每个文件或文件夹的大小 systemctl start &lt;service&gt;开启服务 systemctl enable &lt;service&gt;服务开机自启动 systemctl restert &lt;service&gt;重启服务 systemctl list-unit-files查看服务列表","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"Git基础教程","slug":"git基础教程","date":"2023-04-18T11:12:39.000Z","updated":"2023-05-02T08:27:45.540Z","comments":true,"path":"2023/04/18/git基础教程/","link":"","permalink":"http://example.com/2023/04/18/git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","excerpt":"","text":"Git命令简易汇总 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#初始化git init#添加到暂存区git add &lt;filename&gt;#提交文件git commit -m &quot;&lt;commit descriptrion&gt;&quot;#查看文件修改git diff &lt;filename&gt;#查看暂存区和工作区状态git status#查看历史提交/快照git log#查看历史命令git relog#回退到某一版本git reset --hard &lt;commit_id&gt;/&lt;HEAD^&gt;#比较工作区与版本库最新文件的区别git diff HEAD -- &lt;filename&gt;#撤销文件还未添加的修改（丢弃工作区的修改）git checkout -- &lt;filename&gt;#把上次添加进入暂存区修改的撤销掉，重新加入暂存区（丢弃暂存区的修改）git reset HEAD &lt;file&gt;#删除版本库中文件git rm &lt;filename&gt;#连接远程库git remote add origin git@github.com:&lt;username&gt;/&lt;repositoriyname&gt;.gitgit remote add origin git@gitee.com:&lt;username&gt;/&lt;repositoryname&gt;.git#将本地库推送到远程库git push -u origin main#查看远程库信息git remote -v#切断与远程库的连接git remote rm &lt;name&gt;#将远程库克隆到本地git clone git@github.com:&lt;githubname&gt;/&lt;repositoryname&gt;.git Git简介 Git是目前世界上最先进的分布式版本控制系统，能自动记录每次文件的改动 CVS和SVN都是集中式的版本控制系统，版本库集中存放在中央服务器，最大的毛病是必须联网才能工作。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑都是一个完整的版本库，使用git不需要联网。分布式控制系统安全性更高，因为一个电脑坏掉后，可以复制其他人的版本库 安装Git 1.在Linux上安装Git 若在Debian和Ubuntu上，直接用sudo apt-get install git就能安装，若在老版本的Debian和Ubuntu，用sudo apt-get install git-core下载 其它版本可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入./config make sudo make install即可 2.在Windows上安装Git 在官网下载安装程序，然后默认选项安装，有Git Bash就说明安装成功 安装完成后还需要最后一步配置，在命令行输入： $ git config --global user.name &quot;Your Name&quot;（GitHub用户名） $ git config --global user.email &quot;email@example.com&quot;（GitHub邮箱） 因为Git是分布式版本控制，所以，每个机器都必须自报家门：你的名字和Email地址。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址 创建版本库 版本库即repository，可以简单理解成一个目录，这个目录里所有的文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时候都可以追踪历史，或者在将来某个时刻可以还原。 所以，创建一个版本库非常简单，首先选择一个合适的地方，创建一个空目录，以下操作都在该目录中进行： $ mkdir learngit $ cd learngit 第二步，用git init命令把这个目录变成Git可以管理的仓库： $ git init 初始化后，目录下会多一个.git目录，默认隐藏，这个目录是来跟踪管理版本库的，不要改动。 所有的版本控制系统，只能跟踪文本文件的改动，比如在一个文件的第几行盖了什么。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。 强烈建议使用UTF-8编码来编写文件。使用windows需要注意千万不要使用Windows自带的记事本编辑任何文本文件，原因是Microsoft开发记事本的团队在每个文件开头添加了0x3fbbbf的字符，会导致错误 首先编写一个readme.txt文件，用git add readme.txt命令告诉Git将该文件添加到仓库，用git commit -m &quot;wrote a readme file&quot;告诉Git，把文件提交到仓库，-m后面输入的是本次提交的说明 时光机穿梭 我们已经成功添加并提交了一个readme.txt文件，现在，可以继续修改readme.txt文件，然后运行git status查看结果 git status命令让我们时刻掌握仓库当前的状态，命令的输出告诉我们呢，readme.txt被改动过了，但还没有准备提交的修改 如果想查看怎么修改的readme.txt文件，可以使用git diff这个命令，结果如下 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看different，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。 知道了对readme.txt文件作了什么修改后，再添加到仓库就会很放心，先添加git add readme.txt，然后用git status查看状态，会告诉我们添加的修改包括readme.txt 下一步就可以放心提交$ git commit -m &quot;add distributed&quot;，提交后再用git status查看状态，会告诉我们当前没有需要提交的修改，而且工作目录是干净的 版本回退 现在已经学会了修改文件后提交到Git版本库，就像打游戏一样，每一次存档都相当于一次快照这个快照相当于commit，每次把文件改乱了，或误删了文件，可以从最近的一个commit恢复，然后继续工作，而不是丢失成果。 在Git中，可以使用git log命令查看历史快照记录，若嫌输出信息太多，可以加上参数git log --pretty=oneline，每一个commit id都是独一无二的 要想回退版本，首先要知道在Git中，用HEAD表示当前版本，用HEAD^表示上一个版本，用HEAD~10表示上十个版本。接着用命令git reset --hard HEAD^回退到上一版本，这时若查看历史记录，会发现回退前的版本已经不见了，不过只要窗口还没有关掉，记录回退前版本的commit id，就可用命令git reset --hard 1094a来反回退，版本号没必要写全，Git会自动寻找版本。 Git的版本回退非常快，因为在Git内部使用了指向当前版本的HEAD指针，回退版本时，Git仅仅移动指针，然后顺便把工作区的文件更新。 若第二天回退后悔了，可以用git reflog命令查看使用过历史命令 工作区和暂存区 工作区（Working Directory）就是在电脑中能看到的目录，比如创建的gitlearn文件夹。 版本库（Repository），工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库存了很多东西，其中最重要的就是称为stage（或叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD 前面讲了，把文件往Git版本库添加的时候，是分add和commit两步执行的，git add实际就是把文件修改添加到暂存区，git commit实际就是把暂存区的所有内容提交到当前分支。因为创建Git版本库的时候，Git自动创建了唯一一个master分支，所以现在git commit就是往master分支提交更改 可以简单理解为，需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改。一旦将暂存区内容提交后，git status显示的暂存区就是干净的。 管理修改 Git比其他版本控制系统优秀的原因是：Git跟踪并管理的是修改，而非文件。 若先修改一次文件，然后git add添加，然后第二次修改，然后直接git commit提交，这时会发现第二次修改的进入暂存区内，也就是没有被提交，可用命令git diff HEAD -- readme.txt查看工作区和版本库里面最新版本的区别 那么，怎么提交第二次修改呢？先git add就行了 撤销修改 若大意修改了文件但还没add，使用命令git checkout -- &lt;filename&gt;就能撤销所有修改，回到最近的一次git add时间的状态，即丢弃工作区的修改。 若修改已经放入了暂存区，但还没有提交，Git告诉我们，用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉。 git reset既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本 小结： （1）若乱改了某个文件内容，想丢弃工作区的修改，用命令git checkout -- &lt;file&gt; （2）若不但乱改了内容，还添加到了暂存区，想丢弃修改，第一步用命令git reset HEAD &lt;file&gt;，就回到场景一，第二部按场景一操作git checkout -- &lt;file&gt; （3）已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退，前提是没有推送到远程仓库。 删除文件 在Git中，删除文件也是一个修改操作。当我们用git add提交后，一般情况下用rm来删除文件，这个时候本地的文件删除了，但版本库中还没删除该文件。 此时有两种选择： （1）在版本库中，用git rm &lt;filename&gt;来删除文件，之后再git commit -m &lt;description&gt;即可 （2）删错了，版本库中还有该文件用git checkout即可一键还原 远程仓库 Git是分布式版本控制系统，同一个Git仓库，可以分不到不同的机器上。最早只有一台机器有一个原始版本库，此后别的机器可以“克隆”这个机器的版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 Github提供Git仓库托管服务，可以用作远程仓库，只需要一点设置 首先得创建私钥和公钥，在shell里输入ssh-keygen -t rsa -C &quot;youremail@example.com&quot;然后一路回车，会得到id_rsa和id_rsa.pub文件，前者是私钥，后者是公钥，将公钥添加到Github的key里即可。 Github可以添加多个KEY，假设你有若干电脑，一会在家提交，一会在公司提交，只要把每台电脑的KEY添加到Github即可 添加远程库 Github上的Git仓库，既可以作为备份，又可以让其他人通过该仓库来协作 首先创建一个名为learngit的仓库，然后再本地的learngit仓库中运行命令git remote add origin git@github.com:&lt;username&gt;/&lt;repositoriyname&gt;.git来连接远程库 添加后，远程库的名字就是origin，这是Git默认的叫法。 下一步，将本地库的所有内容推送到远程库上：先将文件添加到本地库，然后用命令git push -u origin main推送到远程库。把本地库的内容推送到远程，用git push命令，实际上是把当前分支main推送到远程。 由于远程库是空的，我们第一次推送main分支时，加上了-u参数，Git不但会把本地的main分支内容推送到远程新的main分支，还会把本地的main分支和远程的main分支关联起来，在以后的推送或者拉取时就可以简化命令，即git push origin main 如果添加的时候地址写错了，可以先用git remote -v查看远程库信息，再用git remote rm &lt;name&gt;来删除远程库，其实就是切断与远程库的连接 分布式版本系统的最大好处之一是在本地工作不需要考虑联网，只要在有网络的时候推送一下就完成同步 从远程库克隆 用克隆命令：git clone git@github.com:&lt;githubname&gt;/&lt;repositoryname&gt;.git即可将远程库的文件克隆到本地 分支管理 Git可以创建分支，自己在自己的分支干活，想提交就提交，最后和主分支合并。 创建和合并分支 在版本回退中，每次提交，Git都会把它们串成一条时间线，这条时间线就是一个分支，这个分支叫主分支。 使用Gitee 使用Github时，国内用户经常会访问太慢，就可以用国内的Gitee托管服务 和Github相比，Gitee也提供免费的Git仓库。使用Gitee和Github类似，都需要先绑定公钥。 创建一个和本地库名相同的远程库，用命令git remote add origin git@gitee.com:&lt;username&gt;/&lt;repositoryname&gt;.git将它和Gitee的远程库关联，之后就可以正常用git push和git pull推送了 若报错说已经关联一个名叫origin的远程库，可以用git remote -v查看远程库信息，然后删除与Github远程库的联系，再关联Gitee的远程库。也可以通过改远程库origin的名称来关联不同的远程库 参考：廖雪峰Git","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"missing-semester","slug":"missing-semester","date":"2023-04-11T14:39:53.000Z","updated":"2023-04-18T14:40:52.606Z","comments":true,"path":"2023/04/11/missing-semester/","link":"","permalink":"http://example.com/2023/04/11/missing-semester/","excerpt":"","text":"Topic 1: The Shell What is the shell? 当我们用各种各样的电脑接口时，我们经常被从根本上限制了。为了充分利用计算机提供的工具，我们不得不走老路下降到文本界面：the Shell 几乎所有的平台都有一个shell，即使他们不同，在各个shell的核心，它们很大程度上相似：它们允许你去运行程序、接受输入、以半结构化的方式检查输出 在这节课，我们将会集中于Bourne Again Shell，即&quot;bash&quot;，它是众多shell中的一员，并且它的语法和其它shell很类似。如果我们想打开一个shell，我们需要一个终端 Using the shell 首先，你会看到一个提示，通常看来是这样 1missing:~$ “missing&quot;是当前工作目录，”~“是&quot;home&quot;的缩写，”$&quot;指没有root权限。你能输入一个命令，将会被shell解释，例如： 12missing:~$ dateFri 10 Jan 2020 11:49:31 AM EST 在这里，我们执行&quot;data&quot;程序，可以打印当前的事件，我么也可以执行一个带参数的程序： 12missing:~$ echo hellohello 在这个例子中，我们告诉shell使用参数hello执行echo，echo程序可以简单的打印它的参数。shell通过空格分割来解析命令，之后运行运行第一个单词指示的程序，之后的单词作为参数来提供程序访问。如果你想提供一个包括空格或者其他特殊符号（e.g，a directory named “My Photos”）作为参数，你能用'或者&quot;来包住 但是，shell怎么知道如何去找这个date或echo程序？shell就是一个变成环境，就像Python和Ruby语言一样，所以它有变量、条件、循环和函数，当用shell执行命令时，实际上是执行一小段shell解释的代码，如果shell被告知要执行一个找不到关键字的命令，它会查询一个名为$PATH的环境变量，这个变量列出了收到命令时应该搜索的程序的目录，例如： 123456missing:~$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binmissing:~$ which echo/bin/echomissing:~$ /bin/echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 当我们运行echo命令，shell会知道它要执行echo命令，然后在PATH中以:为分隔符分离的目录列表中搜索该名称的文件，当它找到后，它会运行命令（假设这个文件可执行）。我们能使用which命令找出要执行的程序在哪个目录，我们也能通过给出要执行的文件的路径来绕过$PATH。 Navigating in the shell shell上的路径是一个带分隔符的目录列表，在Linux和macOS上用/分割，在Windows上用\\ 分割。在Linux中，路径/是文件系统的根目录，所有的目录和文件都位于该路径下 参考：https://missing.csail.mit.edu/2020/","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"DFS(搜索)","slug":"DFS-搜索","date":"2023-04-11T04:22:11.000Z","updated":"2023-04-11T12:20:40.191Z","comments":true,"path":"2023/04/11/DFS-搜索/","link":"","permalink":"http://example.com/2023/04/11/DFS-%E6%90%9C%E7%B4%A2/","excerpt":"","text":"DFS为图论中的概念，详见DFS(图论)页面。在搜索算法中，该词常指利用递归函数方便地暴力枚举的算法，与图论中的DFS算法有一定相似之处，但并不完全相同 比如一种例题，n 等于 m 个数相加之和，每个解从小到大排序，列举出解集。暴力求解是用m层循环，每层循环确定一个数，这样显然效率太低，就要用到递归搜索。 该类算法的特点在于，将要搜索的目标分成若干层，每层基于前几层的状态进行决策，直到达到目标状态。考虑上述问题，即将正整数 n 分解成小于等于 m 个正整数之和，且排在后面的数必须大于等于前面的数 设一组方案将正整数分解成k个正整数$a_1,a_2,…,a_k$的和 我们将问题分层，第 i 层决定$a_i$。则为了进行第 i 层决策，我们需要记录三个状态变量：后面所有正整数的和（$n-\\sum_{j=1}^i{a_j}$）、前一层的正整数（$a_{i-1}$）确保正整数递增；以及$i_{i}$确保最多输出m个正整数。 为了方便记录方案，我们用arr数组，用第 i 项表示$a_i$，注意到arr实际上是一个长度为 i 的栈 代码如下： 1234567891011121314151617int m, arr[103];void dfs(int n,int i,int a)&#123;//i是元素已有的个数，a是当前元素的值 if(n == 0)&#123; for(int j = 1; j &lt;= i -1; j ++)&#123; printf(&quot;%d &quot;,arr[j]); &#125; printf(&quot;%\\n&quot;); &#125; if(i &lt;= m)&#123; for(int j = a; j &lt;= n; j ++)&#123;//遍历a之后的元素 arr[i] = j; dfs(n - j, i + 1, j); &#125; &#125;&#125;scanf(&quot;%d%d&quot;, &amp;n, &amp;m);dfs(n, 1, 1); 例题：LeetCode 17. Letter Combinations of a Phone Number 难度：中等 题意：模拟九键拼音，输入2~9，每个按键对应三个英文字母，输入一个数字序列[123]，输出对应的所有英文组合 题解： emsp; 力扣上的基础搜索回溯题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; combinations; if (digits.empty()) &#123; return combinations; &#125; unordered_map&lt;char, string&gt; phoneMap&#123; &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;, &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125; &#125;;//已经将key和value加入哈希表 string combination; backtrack(combinations, phoneMap, digits, 0, combination); return combinations;//返回包含所有符合的string向量 &#125; //注意函数参数的写法 void backtrack(vector&lt;string&gt;&amp; combinations, const unordered_map&lt;char, string&gt;&amp; phoneMap, const string&amp; digits, int index, string&amp; combination) &#123; if (index == digits.length()) &#123; combinations.push_back(combination); &#125; else &#123; char digit = digits[index]; string letters = phoneMap.at(digit); for (char letter: letters) &#123; combination.push_back(letter); backtrack(combinations, phoneMap, digits, index + 1, combination); combination.pop_back(); &#125; &#125; &#125;&#125;; 简化编写（建议学习正规写法）class Solution &#123;private: unordered_map&lt;char, string&gt; phoneMap&#123; &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;, &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125; &#125;;//已经将key和value加入哈希表public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; combinations; if (digits.empty()) &#123; return combinations; &#125; string combination; backtrack(combinations, digits, 0, combination); return combinations;//返回包含所有符合的string向量 &#125; //注意函数参数的写法 void backtrack(vector&lt;string&gt;&amp; combinations, string digits, int index, string combination) &#123; if (index == digits.length()) &#123; combinations.push_back(combination); &#125; else &#123; char digit = digits[index]; string letters = phoneMap[digit]; for (char letter: letters) &#123;//循环 combination.push_back(letter);//string也能用push_back和pop_back来加减元素 backtrack(combinations, digits, index + 1, combination); combination.pop_back(); &#125; &#125; &#125;&#125;; 参考：OI Wiki","categories":[{"name":"搜索","slug":"搜索","permalink":"http://example.com/categories/%E6%90%9C%E7%B4%A2/"}],"tags":[]},{"title":"LRU缓存","slug":"LRU缓存","date":"2023-04-10T11:37:40.000Z","updated":"2023-04-10T12:30:48.637Z","comments":true,"path":"2023/04/10/LRU缓存/","link":"","permalink":"http://example.com/2023/04/10/LRU%E7%BC%93%E5%AD%98/","excerpt":"","text":"难度：中等 链接：LeetCode 146. LRU Cache 题意：实现一个最近最少使用缓存的数据结构，事先给出缓存区大小，进来一个元素，如果是满的就把最长时间未用的元素挤出去 题解： 手写一个双向链表来存储结点，用哈希表unorder_map（便于查找）来定位&lt;key,value&gt;对，其中value是双向链表的结点。靠近头部的是最新的，靠近尾部的是最久未使用的。 先用哈希表定位，然后找出缓存项的位置，然后操作 对于get操作，若存在，用哈希表定位位置（DLinkedNode *node = cache[key]），然后移动到头结点（注意移动操作是先删除结点后插入到头结点，所以时间复杂度为$O(1)$），最后返回该结点的值 对于put操作，若存在，和get类似，需要更新value；若不存在，创建一个新结点插入到头结点，若size超量，删除尾结点，并erase对应项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//手写双向链表struct DLinkedNode &#123; int key,value; DLinkedNode *prev; DLinkedNode *next; DLinkedNode(): key(0),value(0),prev(NULL),next(NULL)&#123;&#125; DLinkedNode(int _key,int _value): key(_key),value(_value),prev(NULL), next(NULL)&#123;&#125;&#125;;class LRUCache &#123; private: //unordered_map内部实现是哈希表，无序的，优点便于查找 unordered_map&lt;int,DLinkedNode*&gt; cache;//前数值后结点 DLinkedNode *head;//虚拟头节点 DLinkedNode* tail;//虚拟尾结点 int size; int capacity; public: LRUCache(int _capacity): capacity(_capacity),size(0) &#123; //初始化 head = new DLinkedNode(); tail = new DLinkedNode(); head-&gt;next = tail; tail-&gt;next = head; &#125; int get(int key) &#123; //map的count(key)函数判断是否存在元素 //区别是即使元素=0，count也返回1 //对应的erase(key)函数是清除记录 if(!cache.count(key))&#123; return -1; &#125; //如果存在，先通过哈希表定位，再转移到头部（更新） DLinkedNode *node = cache[key]; moveToHead(node); return node-&gt;value; &#125; void put(int key, int value) &#123; if(!cache.count(key))&#123; //如果不存在，创建一个新的结点 DLinkedNode *node = new DLinkedNode(key,value); //添加进哈希表 cache[key] = node; //添加至双向链表的头部 addToHead(node); size++; if(size &gt; capacity)&#123; //如果超出容量，删除双向链表的尾部结点 DLinkedNode *removed = removeTail(); //删除哈希表中对应的项 cache.erase(removed-&gt;key); //防止内存泄漏 delete removed; size--; &#125; &#125; else &#123; //若存在，先通过哈希表定位，再更新value，并转移到头部 DLinkedNode *node = cache[key]; node-&gt;value = value; moveToHead(node); &#125; &#125; void addToHead(DLinkedNode *node)&#123; //将node添加到双向链表头结点 node-&gt;prev = head; node-&gt;next = head-&gt;next; head-&gt;next-&gt;prev = node; head-&gt;next = node; &#125; void removeNode(DLinkedNode *node)&#123; //删除结点 node-&gt;prev-&gt;next = node-&gt;next; node-&gt;next-&gt;prev = node-&gt;prev; &#125; void moveToHead(DLinkedNode *node)&#123; //将结点移到头结点，直接删除和添加结点，所以是O(1) removeNode(node); addToHead(node); &#125; DLinkedNode *removeTail()&#123; //删除尾结点 DLinkedNode *node = tail-&gt;prev; removeNode(node); return node; &#125;&#125;;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"哈希","slug":"哈希","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C/"}]},{"title":"链表排序","slug":"链表排序","date":"2023-04-08T13:47:58.000Z","updated":"2023-04-09T14:57:09.561Z","comments":true,"path":"2023/04/08/链表排序/","link":"","permalink":"http://example.com/2023/04/08/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/","excerpt":"","text":"难度：中等 链接：Sort List 题意：在时间复杂度为O(nlogn)内，空间复杂度为O(1)内对给定首元结点的链表排序 归并排序（递归实现自顶向下） 归并排序的思想是：将数组拆分成两半，对两半再进行归并排序，最后进行有序合并 时间复杂度为$O(n logn)$，空间复杂度为$O(logn)$ 若要在链表中实现归并排序（递归法），需要以下子方法： ListNode *findMid(ListNode *head) 找到链表中点： 123456789101112//双指针找链表中点，偶数个结点时取中间偏左的结点ListNode *findMid(ListNode *head)&#123; if(head == NULL) return head; ListNode *fast = head-&gt;next; ListNode *slow = head; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)&#123; fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; &#125; return slow;&#125; ListNode *mergeSort(ListNode *head) 每次找到链表中点，断开，对两边再进行mergeSort 1234567891011121314ListNode *mergeSort(ListNode *head)&#123; if(head == NULL || head-&gt;next == NULL)&#123; return head; &#125; ListNode *mid = findMid(head); ListNode *next = mid-&gt;next; mid-&gt;next=NULL;//断开mid和下一个结点 ListNode *left = mergeSort(head); ListNode *right = mergeSort(next); return merge(left,right); &#125; ListNode *merge(ListNode *l1,ListNode *l2) 合并两个升序的链表 12345678910111213141516171819202122ListNode *merge(ListNode *l1,ListNode *l2)&#123; ListNode *dummy = new ListNode();//新建个链表 ListNode *curr = dummy; while(l1 != NULL &amp;&amp; l2 != NULL)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; curr-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; curr-&gt;next = l2; l2 = l2-&gt;next; &#125; curr = curr-&gt;next; &#125; if(l1 != NULL)&#123; curr-&gt;next = l1; &#125; if(l2 != NULL)&#123; curr-&gt;next = l2; &#125; return dummy-&gt;next;&#125; 最终代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: ListNode *findMid(ListNode *head)&#123; if(head == NULL) return head; ListNode *fast = head-&gt;next; ListNode *slow = head; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)&#123; fast=fast-&gt;next-&gt;next; slow=slow-&gt;next; &#125; return slow; &#125; ListNode *mergeSort(ListNode *head)&#123; if(head == NULL || head-&gt;next == NULL)&#123; return head; &#125; ListNode *mid = findMid(head); ListNode *next = mid-&gt;next; mid-&gt;next=NULL;//断开mid和下一个结点 ListNode *left = mergeSort(head); ListNode *right = mergeSort(next); return merge(left,right); &#125; ListNode *merge(ListNode *l1,ListNode *l2)&#123; ListNode *dummy = new ListNode();//新建个链表 ListNode *curr = dummy; while(l1 != NULL &amp;&amp; l2 != NULL)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; curr-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; curr-&gt;next = l2; l2 = l2-&gt;next; &#125; curr = curr-&gt;next; &#125; if(l1 != NULL)&#123; curr-&gt;next = l1; &#125; if(l2 != NULL)&#123; curr-&gt;next = l2; &#125; return dummy-&gt;next; &#125; ListNode* sortList(ListNode* head) &#123; return mergeSort(head); &#125;&#125;; 归并排序（迭代实现自底向上） 用迭代实现可以达到$O(nlogn)$的时间复杂度和$O(1)$的空间复杂度 想法是先把数组分割成含有1个结点的子链表，分割后从头开始每相邻两个子链表有序合并，然后step增大一倍变为2，再相邻有序合并，step增大一倍变为4，持续合并，最后就成了一个有序链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; ListNode *dummy = new ListNode(); dummy-&gt;next = head; //获取链表长度 int len=0; ListNode *curr = head; while(curr != NULL)&#123; len ++; curr = curr-&gt;next; &#125; //循环遍历 //外层遍历step，内层处理每step个元素进行一次merge for(int step = 1; step &lt; len; step *= 2)&#123; ListNode *tail = dummy; curr = dummy-&gt;next; while(curr != NULL)&#123; //left和right是两个相邻的链表，各有step个元素 ListNode *left = curr; ListNode *right = cut(left,step); //巧用cut使成为curr下次开始的点 curr = cut(right,step); //tail用来连接链表 tail-&gt;next = merge(left,right); while(tail-&gt;next != NULL)&#123; tail = tail-&gt;next; &#125; &#125; &#125; return dummy-&gt;next; &#125; ListNode *cut(ListNode *from,int step)&#123; //将链表从from开始切掉前step个元素，返回后一个元素（断链 step --; while(from != NULL &amp;&amp; step &gt;0)&#123; from = from-&gt;next; step --; &#125; //包括from，切掉 if(from == NULL)&#123; return NULL;//到了尾结点，返回NULL &#125; else &#123; ListNode *next = from-&gt;next; from-&gt;next = NULL;//断链 return next;//返回from-&gt;next; &#125; &#125; ListNode *merge(ListNode *l1,ListNode *l2)&#123; //合并两个有序链表 ListNode *dummy = new ListNode();//新建个链表 ListNode *curr = dummy; while(l1 != NULL &amp;&amp; l2 != NULL)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; curr-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; curr-&gt;next = l2; l2 = l2-&gt;next; &#125; curr = curr-&gt;next; &#125; if(l1 != NULL)&#123; curr-&gt;next = l1; &#125; if(l2 != NULL)&#123; curr-&gt;next = l2; &#125; return dummy-&gt;next; &#125;&#125;; 参考： https://leetcode.cn/problems/sort-list/solution/by-nuo-nuo-zi-4-xrok/","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Vim简单应用","slug":"Vim简单应用","date":"2023-04-08T09:35:07.000Z","updated":"2023-04-09T15:16:55.593Z","comments":true,"path":"2023/04/08/Vim简单应用/","link":"","permalink":"http://example.com/2023/04/08/Vim%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/","excerpt":"","text":"1、模式转换 命令行模式可以输入i、a等进入编辑模式 编辑模式点击esc按键进入命令行模式 命令行模式点击shift+;进入低行模式 2、编辑模式 i 从目前光标所在处插入 I 在当前所在行的第一个非空字符处插入，可用0i替代 a 从当面光标所在的下一个字符处插入 A 从当前光标所在行的最后一个字符处开始插入，可以用$a替代 o 在当前光标所在的下一行处插入新的一行 O 在当前光标所在的上一行后插入新的一行 s 删除光标所在字符并开始插入 S 删除光标所在行并开始插入 3、低行模式 :w 保存文件但不退出vim :w file 将修改另外保存到file中，不退出vim :!w 强制保存，不推出vim :wq 保存文件并退出vim :!wq 强制保存文件，并退出vim :q 不保存文件，退出vi :!q 不保存文件，强制退出vim :!e 放弃所有修改，从上次保存文件开始再编辑命令历史 4、光标移动 h 左移、l 右移、j 下移、k 上移 n+空格 移动到这行该字符后第n个字符 0 移动到该行最前面字符处 ^ 移动到该行最前面非空字符处 $ 移动到该行最后 gg 移动到第一行 G 移动到最后一行 ngg 或 nG 移动到第n行 n 移动到光标下n行 5、撤回、删除、复制和粘贴 u 撤销上一步操作 ctrl+r 恢复上一步被撤销的操作 . 重复上一步操作 nx 向后删除n个字符 X 向前删除一个字符 ndd 删除光标所在的向下n行 d1G 删除光标所在到第一行的全部数据 dG 删除光标到最后一行 d$ 删除光标到该行最后一个字符 d0 删除光标到该行第一个字符 nyy 复制光标所在的向下n行 y1G 复制光标所在到第一行的全部数据 yG 复制光标到最后一行 y$ 复制光标到该行最后一个字符 y0 复制光标到该行第一个字符 p 粘贴到光标所在的前一行 P 粘贴到光标所在的后一行 J 光标所在行与下一行的数据结合成一行 6、搜索与替换 /word 光标向下搜索并高亮第一个word 搜索到后，n 向下搜索下一个word，N 向上反向","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"找出环形链表的入环第一个结点","slug":"找出环形链表的入环第一个结点","date":"2023-04-07T13:57:04.000Z","updated":"2023-04-07T15:11:57.628Z","comments":true,"path":"2023/04/07/找出环形链表的入环第一个结点/","link":"","permalink":"http://example.com/2023/04/07/%E6%89%BE%E5%87%BA%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E7%8E%AF%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/","excerpt":"","text":"难度：中等 链接：Linked List Cycle II 题意：给一个可能有环的链表，若不存在环输出-1，找出入环的第一个结点并返回 题解： 方法一：哈希表 因为每个结点是不同的，所以就可以用哈希表存每个结点，一旦遇到重复结点就一定有环 缺点：用时和占用内存都比较大 123456789101112131415161718192021222324252627282930class Solution &#123;//用map也可实现public: ListNode *detectCycle(ListNode *head) &#123; map&lt;ListNode *,int&gt; visited; while (head != nullptr) &#123; if (visited[head]!=0) &#123; return head; &#125; visited[head]++; head = head-&gt;next; &#125; return nullptr; &#125;&#125;;/*class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; unordered_set&lt;ListNode *&gt; visited; while (head != nullptr) &#123; if (visited.count(head)) &#123; return head; &#125; visited.insert(head); head = head-&gt;next; &#125; return nullptr; &#125;&#125;;*/ 双指针法 12345678910111213141516171819202122class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode *slow=head,*fast=head; while(fast!=NULL)&#123; slow=slow-&gt;next; if(fast-&gt;next==NULL)&#123; return NULL; &#125; fast=fast-&gt;next-&gt;next; if(fast==slow)&#123; ListNode *ptr=head; while(ptr!=slow)&#123; ptr=ptr-&gt;next; slow=slow-&gt;next; &#125; return ptr; &#125; &#125; return NULL; &#125;&#125;;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"对链表插入排序","slug":"对链表插入排序","date":"2023-04-05T14:16:17.000Z","updated":"2023-04-05T14:52:45.003Z","comments":true,"path":"2023/04/05/对链表插入排序/","link":"","permalink":"http://example.com/2023/04/05/%E5%AF%B9%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"难度：中等 题目链接：LeetCode 147. Insertion Sort List 题意：给出首元结点为head的链表，用插入排序来让这个链表有序 题解： 插入排序的本质是维护一个有序数组，每次将待排序元素插入到这个数组中。在链表中，只需要有序数组的最后一个元素lastsorted还有待排序元素curr即可，如果curr大于lastsorted就不管，如果curr小于lastsorted的话，就定义一个pre找到待插入位置，先把curr隐去，然后把curr插入过去就行，然后curr=lastsorted-&gt;next即可 这种方法每次只需比较相邻的两个结点大小，如果curr小就遍历一遍前面的元素然后插入，如果大就不管，时间复杂度控制的好 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if (head == NULL) &#123; return head; &#125; ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; ListNode* lastSorted = head; ListNode* curr = head-&gt;next; while (curr != NULL) &#123; if (lastSorted-&gt;val &lt;= curr-&gt;val) &#123; lastSorted = lastSorted-&gt;next; &#125; else &#123; ListNode *prev = dummyHead; while (prev-&gt;next-&gt;val &lt;= curr-&gt;val) &#123; prev = prev-&gt;next; &#125; lastSorted-&gt;next = curr-&gt;next;//隐去curr结点 curr-&gt;next = prev-&gt;next; prev-&gt;next = curr;//插入curr结点 &#125; curr = lastSorted-&gt;next;//注意curr结点可以重用 &#125; return dummyHead-&gt;next; &#125;&#125;;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"合并有序链表","slug":"合并有序链表","date":"2023-04-04T13:42:25.000Z","updated":"2023-04-05T14:53:10.899Z","comments":true,"path":"2023/04/04/合并有序链表/","link":"","permalink":"http://example.com/2023/04/04/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"","text":"难度：简单 链接：https://leetcode.cn/problems/merge-two-sorted-lists/ 题意：给两个有序链表，将其合并为一个链表并返回首元结点。 题解： 假设将list2合并到list1上，先定义虚拟头结点和pre，遍历两个链表，如果list2&gt;list1，就让list1和pre后移，否则list2&lt;=list1将q-&gt;val=list2-&gt;val插入到pre和list之间。遍历到list2结束，如果此时list1有剩余可以不处理，如果list2有剩余，就让pre-&gt;next=list2 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123; ListNode *dummynode = new ListNode(); dummynode-&gt;next=list1;//定义头结点很方便 ListNode *pre=dummynode; while(list1!=NULL&amp;&amp;list2!=NULL)&#123; if(list2-&gt;val&gt;list1-&gt;val)&#123; list1=list1-&gt;next; pre=pre-&gt;next; &#125; else&#123; ListNode *q=new ListNode(); q-&gt;val=list2-&gt;val; pre-&gt;next=q; q-&gt;next=list1; list2=list2-&gt;next; pre=pre-&gt;next; &#125; &#125; if(list1==NULL)&#123; pre-&gt;next=list2; &#125; return dummynode-&gt;next; &#125;&#125;;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"重排链表","slug":"重排链表","date":"2023-04-03T10:14:24.000Z","updated":"2023-04-07T13:05:09.113Z","comments":true,"path":"2023/04/03/重排链表/","link":"","permalink":"http://example.com/2023/04/03/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/","excerpt":"","text":"难度：中等 题目链接：https://leetcode.cn/problems/reorder-list/ 题解： 方法一：寻找链表中点+反转链表+合并链表 注意到结果正是把链表中点的后半反转后（不包括中点，且偶数结点中中点是中间两个结点的后者），邻一个插入到前半链表，空间复杂度为$O(1)$ 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; */class Solution&#123;public: ListNode *middleNode(ListNode *head) // 找链表中点 &#123; ListNode *first = head, *second = head; // 快慢指针 while (first != NULL &amp;&amp; first-&gt;next != NULL) &#123; first = first-&gt;next-&gt;next; second = second-&gt;next; &#125; return second; &#125; ListNode *reverseList(ListNode *head) // 迭代法将中点后反转链表 &#123; ListNode *prev = nullptr; ListNode *curr = head; while (curr != nullptr) &#123; ListNode *nextTemp = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = nextTemp; &#125; return prev; &#125; void mergeList(ListNode *l1, ListNode *l2) &#123; ListNode *l1_tmp; ListNode *l2_tmp; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; l1_tmp = l1-&gt;next; // 因为要改变结点的next l2_tmp = l2-&gt;next; // 所以先用tmp结点存当前结点的next结点 l1-&gt;next = l2; l1 = l1_tmp; l2-&gt;next = l1; l2 = l2_tmp; &#125; &#125; void reorderList(ListNode *head) &#123; if (head == NULL) &#123; return; &#125; ListNode *mid = middleNode(head); // 找中点或偶数中点后一个结点 ListNode *l1 = head; ListNode *l2 = mid-&gt;next; // 两段链表 mid-&gt;next = NULL; // 断链 l2 = reverseList(l2); // 反转链表 mergeList(l1, l2); &#125;&#125;; 方法二：线性表 由于链表不支持下标访问，所以无法随机访问链表的元素，可以用vector来当作线性表存链表结点 此方法空间复杂度$O(n)$，用线性表比较大 代码如下： 12345678910111213141516171819202122232425262728293031class Solution&#123;public: void reorderList(ListNode *head) &#123; if (head == NULL) &#123; return;//因为是void型，直接用return结束 &#125; vector&lt;ListNode *&gt; vec; ListNode *node = head; while (node != nullptr) &#123; vec.push_back(node); node = node-&gt;next;//线性表vec存链表结点 &#125; int i = 0, j = vec.size() - 1; while (i &lt; j) &#123; vec[i]-&gt;next = vec[j]; i++; if (i == j) &#123; break; &#125; vec[j]-&gt;next = vec[i]; j--;//用i++和j--可以找下一个变量和上一个变量 &#125; vec[i]-&gt;next = NULL; &#125;&#125;;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"链表","slug":"链表","date":"2023-04-03T10:04:57.000Z","updated":"2023-04-03T11:00:11.854Z","comments":true,"path":"2023/04/03/链表/","link":"","permalink":"http://example.com/2023/04/03/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"示例代码：包括两种方法建立，查找，删除，输出，反转，找中点，交叉合并 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int n, i;int a[100];typedef struct LNode&#123; int data; struct LNode *next;&#125; *List, node; // List和node * 同义void HeadCreatList(List H) // 头插法&#123; node *p; for (i = 1; i &lt;= n; i++) &#123; p = (List)malloc(sizeof(List)); p-&gt;data = a[i]; p-&gt;next = H-&gt;next; H-&gt;next = p; &#125;&#125;void TailCreatList(List H) // 尾插法&#123; node *p, *r; r = H; // r是尾指针，一直指向最后一个结点 for (i = 1; i &lt;= n; i++) &#123; p = (List)malloc(sizeof(List)); p-&gt;data = a[i]; r-&gt;next = p; r = p; &#125; r-&gt;next = NULL; // r是最后一个结点，最后一个节点后接空&#125;node *Search(List H, int x, int *w) // 查找x在链表中的下标&#123; node *p; int n = 0; p = H-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != x) &#123; p = p-&gt;next; n++; &#125; if (p != NULL) &#123; *w = n + 1; // 因为当p-&gt;data==x时就跳出循环，所以加1 return p; &#125; else &#123; *w = 0; return NULL; &#125;&#125;void Delete(List H, int x) // 删除为x的数据&#123; node *pre, *p, *q; pre = H; // pre用作前驱 p = H-&gt;next; // p是当前结点 while (p != NULL) &#123; if (p-&gt;data == x) &#123; q = p; // 存结点 pre-&gt;next = p-&gt;next; p = pre-&gt;next; free(q); // 释放结点 &#125; else &#123; pre = pre-&gt;next; p = p-&gt;next; &#125; &#125;&#125;void Insert(List H, int x) // 将x插入链表中的第一个大于它的数的前边&#123; node *pre, *p, *q; pre = H; // 前驱 p = H-&gt;next; while (p != NULL &amp;&amp; p-&gt;data &lt; x) &#123; // p停在第一个大于等于x的结点 pre = pre-&gt;next; p = p-&gt;next; &#125; q = (List)malloc(sizeof(List)); q-&gt;data = x; pre-&gt;next = q; q-&gt;next = p;&#125; // 若想创建一个有序的链表，就输入每个值然后调用一次Insert就好void print(List H)&#123; node *p; p = H-&gt;next; while (p != NULL) &#123; printf(&quot;%d &quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;void reverseList(node *head) // 反转链表，注意这里head是H-&gt;next&#123; node *pre, *p; pre = NULL; // pre一开始在头结点 p = head; // p一开始在首元结点 while (p != NULL) &#123; node *q = p-&gt;next; p-&gt;next = pre; // 改变p点的指针指向 pre = p; // 将pre移向下一个结点 p = q; // 将p移向下一个结点 &#125;&#125;node *middleNode(node *head) // 找链表中点，注意这里head是H-&gt;next&#123; node *first = head, *second = head; // 快慢指针 while (first != NULL &amp;&amp; first-&gt;next != NULL) &#123; first = first-&gt;next-&gt;next; second = second-&gt;next; &#125; return second;&#125;void mergeList(node *l1, node *l2) // 相邻挨个插入&#123; node *l1_tmp; node *l2_tmp; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; l1_tmp = l1-&gt;next; // 因为要改变结点的next l2_tmp = l2-&gt;next; // 所以先用tmp结点存当前结点的next结点 l1-&gt;next = l2; l1 = l1_tmp; l2-&gt;next = l1; l2 = l2_tmp; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; List H; H = (List)malloc(sizeof(List)); H-&gt;next = NULL; TailCreatList(H); print(H); int x, w; printf(&quot;要查找的数据：&quot;); scanf(&quot;%d&quot;, &amp;x); node *z = Search(H, x, &amp;w); if (z == NULL) &#123; printf(&quot;不在链表中\\n&quot;); &#125; else printf(&quot;在链表中下标为：%d\\n&quot;, w); printf(&quot;要删除的数据：&quot;); scanf(&quot;%d&quot;, &amp;x); Delete(H, x); printf(&quot;删除后：&quot;); print(H); printf(&quot;要插入的数据（递增）：&quot;); scanf(&quot;%d&quot;, &amp;x); Insert(H, x); printf(&quot;插入后：&quot;); print(H); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"反转部分链表","slug":"反转部分链表","date":"2023-04-02T14:35:50.000Z","updated":"2023-04-03T10:17:07.107Z","comments":true,"path":"2023/04/02/反转部分链表/","link":"","permalink":"http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8/","excerpt":"","text":"难度：中等 题目链接：https://leetcode.cn/problems/reverse-linked-list-ii/description/ 题意：反转链表的一部分，从left到right，例如[1,2,3,4,5]，left=2，right=4时，解为[1,4,3,2,5] 题解：反转部分链表可实现，但是反转后如何连接起来需要考虑，即将left-1与right、left与right+1连接起来，需要记录这些结点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * &#125;; */class Solution &#123;private: void reverseLinklist(ListNode *head)&#123; ListNode *pre,*p; pre=NULL;//pre一开始在头结点 p=head;//p一开始在首元结点 while(p!=NULL)&#123; ListNode *q=p-&gt;next; p-&gt;next=pre;//改变p点的指针指向 pre=p;//将pre移向下一个结点 p=q;//将p移向下一个结点 &#125; //不需要返回，因为结点名称不变 &#125;public: ListNode* reverseBetween(ListNode* head, int left, int right) &#123; ListNode *dummyhead = new ListNode(); dummyhead-&gt;next=head;//定义虚拟头结点，因为首元结点可能变化 ListNode *pre = dummyhead; for(int i=0;i&lt;left-1;i++)&#123; pre=pre-&gt;next;//从头结点走left-1步，定格在left-1结点处 &#125; ListNode *rightNode = pre;//接力pre结点，继续往下循环 for(int i = 0; i &lt; right - left + 1 ; i++)&#123; rightNode = rightNode-&gt;next;//rightNode循环到right结点 &#125; ListNode *leftNode = pre-&gt;next;//指向left ListNode *curr = rightNode-&gt;next;//指向right+1 pre-&gt;next = NULL; rightNode-&gt;next=NULL;//切断链接，截取链表 reverseLinklist(leftNode);//反转部分链表，各结点位置不变 pre-&gt;next=rightNode;//连接前部分 leftNode-&gt;next=curr;//连接后部分 return dummyhead-&gt;next; &#125;&#125;;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"反转链表","slug":"反转链表","date":"2023-04-02T12:47:07.000Z","updated":"2023-04-03T13:20:57.862Z","comments":true,"path":"2023/04/02/反转链表/","link":"","permalink":"http://example.com/2023/04/02/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"难度：简单 题目链接：https://leetcode.cn/problems/reverse-linked-list/description/ 题意：给出一个链表的头结点（首元结点），将该链表反转后，返回反转后的链表 题解： 方法一：迭代 直接在遍历链表的过程中原地修改，将当前结点的next指针改为指向前一个节点，然后将p和pre结点都后移，需要借助p的后面结点，所以循环的开始先定义一个q=p-&gt;next; 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *pre,*p; pre=NULL;//pre一开始在头结点 p=head;//p一开始在首元结点 while(p!=NULL)&#123; ListNode *q=p-&gt;next; p-&gt;next=pre;//改变p点的指针指向 pre=p;//将pre移向下一个结点 p=q;//将p移向下一个结点 &#125; return pre;//遍历到结尾时，pre在最后一个结点 &#125;&#125;; 方法二：递归 一直递归到倒数第二个结点，找到结果头结点newhead，然后执行head-&gt;next-&gt;next=null反转最后一个结点和倒数第二个结点的指针，改变head-&gt;next=NULL，然后回退挨个反转。 123456789101112class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL)&#123;//为什么head==NULL? 测试用例有空链表 return head;//最后返回的是最后一个结点，让newhead等于最后一个结点 &#125; ListNode *newhead = reverseList(head-&gt;next);//注意，只会执行一次 head-&gt;next-&gt;next=head;//该行代码第一次执行时是倒数第二个结点，反转指针 head-&gt;next=NULL;//提前定义空指针 return newhead;//一直返回最后的头结点 &#125;&#125;;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"迭代&递归&分治","slug":"迭代-递归-分治","date":"2023-04-02T12:02:43.000Z","updated":"2023-04-09T15:17:41.514Z","comments":true,"path":"2023/04/02/迭代-递归-分治/","link":"","permalink":"http://example.com/2023/04/02/%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92-%E5%88%86%E6%B2%BB/","excerpt":"","text":"迭代 1.迭代法称为辗转法，不断的用变量旧值求出新值，即对一组指令循环执行，最终得到新值作为结果。 2.在代码中表现为在一个循环内，不断循环最终得到结果。 递归 1.定义：递归在数学和计算机科学中指在函数的定义中使用函数自身的方法，还额外指一种通过重复将问题分解为同类子问题而解决问题的方法。基本思想是某个函数直接或间接地调用自身，在求解过程中只需关注如何把原问题划分成符合条件的子问题，不需要过分关注子问题如何解决。 2.特征：结束条件和自我调用，示例概括代码如下： 123456int func(传入数值)&#123; if (终止条件) return 最小子问题解; return func(缩小规模);&#125; 3.缺点：在程序执行中，递归是利用堆栈实现的，每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧，递归层数过多会栈溢出。简单的递归不会消耗空间，比如给出链表头，计算长度的递归代码： 123456int size_recursion(Node *head)&#123; if (head == nullptr) return 0; return size_recursion(head-&gt;next) + 1;//有一个结点加一次1&#125; 分治 1.定义：把一个复杂问题分成多个相同或相似的子问题，直到最后子问题都可以直接求解，原问题即子问题的解的合并。分治问题能通过递归算法解决，也能通过非递归算法解决，通常用递归算法 2.过程： 分解原问题为结构相同的子问题 分解到某个容易求解的边界之后，进行递归求解 将子问题的解合并成原问题的解 3.能解决的问题特征： 该问题的规模缩小到一定程度就可以容易地解决 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并成该问题的解 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。(若子问题不相互独立，一般用动态规划) 4.分治与递归的区别：递归是一种变成技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体的算法思想。 参考： https://oi.wiki","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"删除链表的倒数第N个结点","slug":"删除链表的倒数第N个结点","date":"2023-03-31T23:28:59.000Z","updated":"2023-04-03T11:12:01.202Z","comments":true,"path":"2023/04/01/删除链表的倒数第N个结点/","link":"","permalink":"http://example.com/2023/04/01/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/","excerpt":"","text":"用一趟扫描实现： 题解：本题是力扣上的题，注意力扣上说的头结点是指首元结点，带有数据域，那么就需要设置一个虚拟头结点来指向首元结点，用双指针遍历，first遍历到结尾时与second正好相差n个元素 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *dummyhead=new ListNode();//设置虚拟头节点 dummyhead-&gt;next=head; ListNode *first,*second; first=second=dummyhead; while(n--)&#123; first=first-&gt;next;//双指针相差n个， &#125; //此时first与second相差n个，但是当first到结尾时second-&gt;next才是要删除的 while(first-&gt;next!=NULL)&#123;//遍历到结尾 first=first-&gt;next; second=second-&gt;next; &#125; second-&gt;next=second-&gt;next-&gt;next;//删除second-&gt;next return dummyhead-&gt;next;//返回dummyhead-&gt;next，因为有可能首元结点被删去，需要用虚拟头结点 &#125;&#125;; 题目链接","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"一些tips","slug":"一些Tip","date":"2023-03-29T13:41:37.000Z","updated":"2023-04-09T15:17:14.904Z","comments":true,"path":"2023/03/29/一些Tip/","link":"","permalink":"http://example.com/2023/03/29/%E4%B8%80%E4%BA%9BTip/","excerpt":"","text":"1.定义比较大的数组的时候（例如1e5），要放在全局变量，否则ide会提示段错误 2.ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);清除内存，超内存超时时用，大数据集快不少 3.力扣上说的头结点意思是首元结点，带有数据域，若要删除首元结点，就需要定义一个虚拟头节点dummynode，别忘了分配空间。（翻译问题？） 4.如果从头结点开始遍历，一般让p-&gt;next!=NULL；从首元结点开始遍历就让p!=NULL","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"排序","slug":"排序","date":"2023-03-24T12:33:17.000Z","updated":"2023-04-09T15:06:01.791Z","comments":true,"path":"2023/03/24/排序/","link":"","permalink":"http://example.com/2023/03/24/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序相关STL 1.std::sort 1.两种用法：sort(a,a+n)或者sort(a,a+n,cmp); 2.未指定cmp函数时，sort是从小到大的顺序排列，c++标准以及以后的标准要求最坏时间复杂度为$O(n \\log n)$ 3.使用cmp函数的示例代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;struct ab&#123; int a, b;&#125; p[100];bool cmp(ab x, ab y)&#123; if (x.a == y.a) &#123; return x.b &lt; y.b; // 从小到大顺序 &#125; else return x.a &lt; y.a;&#125;int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; p[i].a &gt;&gt; p[i].b; &#125; sort(p, p + n, cmp); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; p[i].a &lt;&lt; &quot; &quot; &lt;&lt; p[i].b &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125;/*55 44 43 43 52 1*/ 2.stable_sort 1、用法和sort一样，不过是稳定排序 3.nth_element 1、nth_element(a,a+k,a+n);，使第n小的数在第k位就位，然后输出a[k]即可 选择排序 1、原理：每次循环，找出 第i小的元素，即剩下最小的元素，然后和数组中第i个位置上的元素交换。 2、稳定性：由于需要交换元素，是一种不稳定的排序算法 3、时间复杂度：最优、平均、最坏时间复杂度均为$O(n^2)$ 4、代码实现： 123456789101112131415void selection_sort(int *a, int n)&#123; for (int i = 1; i &lt; n; i++) &#123; int ith = i; for (int j = i + 1; j &lt;= n; j++) &#123; if (a[j] &lt; a[ith]) &#123; ith = j; &#125; &#125; swap(a[i], a[ith]); &#125;&#125; 冒泡排序 1、原理：每次检查相邻元素，如果相邻元素满足给定的顺序交换条件，就将相邻的两个元素交换，每次循环，必有一个最值靠边，所以最多扫描n-1遍数组 2、稳定性：冒泡排序是一种稳定的排序算法 3、时间复杂度：完全有序时，只需遍历一遍数组，时间复杂度$O(n)$；最坏情况下，冒泡排序要执行$\\frac{n(n-1)}{2}$次交换，时间复杂度$O(n^2)$；平均时间复杂度为$O(n^2)$。 4、代码实现： 1234567891011121314151617181920212223242526272829// 假设数组的大小是 n + 1，冒泡排序从数组下标 1 开始void bubble_sort(int *a, int n)&#123; bool flag = true; while (flag) &#123; flag = false; // 判断若完美数组直接退出 for (int i = 1; i &lt; n; i++) &#123; if (a[i] &gt; a[i + 1]) &#123; flag = true; int t = a[i]; a[i] = a[i + 1]; a[i + 1] = t; &#125; &#125; &#125;&#125;或者：// 假设数组的大小是len，冒泡排序从数组下标0开始void bubble_sort(int *arr, int len)&#123; int i, j; for (i = 0; i &lt; len - 1; i++) for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) swap(arr[j], arr[j + 1]);&#125; 插入排序 1、原理：将原数组划分为待排序部分和已排序部分，每次从待排序不放呢选择一个元素插入到已排序中，最后形成已排序数组 2、稳定性：插入排序是一种稳定的排序算法 3、时间复杂度：最优时间复杂度为$O(n)$，最坏和平均时间复杂度均为$O(n^2)$ 4、代码实现： 1234567891011121314void insertion_sort(int arr[], int len)&#123; // 从小到大，已排序好的在前面 for (int i = 1; i &lt; len; ++i) &#123; int key = arr[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) // 每次循环将a[i]插入a[0]到a[i-1]的有序数组中 &#123; arr[j + 1] = arr[j]; // 给arr[i]让位置 j--; &#125; arr[j + 1] = key; &#125;&#125; 计数排序 1、原理：使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数，然后根据数组C将A中的元素排到正确的位置 2、步骤：（1）计算每个数出现几次（2）求出每个数出现次数的前缀和（3）利用出现次数的前缀和，从右至左计算每个数的排名 3、稳定性：计数排序是一种稳定的排序算法 4、时间复杂度：均为$O(n+w)$，其中$w$代表排序数据的值域大小 5、代码实现： 123456789101112131415161718const int N = 100010;const int W = 100010;// 注意，此算法有局限性，必须知道值域w，数组下标为1~nint n, w, a[N], cnt[W], b[N];void counting_sort()&#123; memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) cnt[a[i]]++; for (int i = 1; i &lt;= w; i++) cnt[i] += cnt[i - 1]; for (int i = n; i &gt;= 1; i--) // 逆序为了保持稳定性 &#123; b[cnt[a[i]]] = a[i]; cnt[a[i]]--; &#125;&#125; 基数排序 1、定义：基数排序是一种非比较型的排序算法，将待排序的数组中的每个元素拆分为$k$个关键字，逐一对各个关键字排序后完成对所有元素的排序。 2、关键字元素的比较：从第一关键字一直比较到最后一个关键字，如果按顺序某个$a_i&gt;b_i$，则$a&gt;b$。对于自然数，将自然数按个位对齐后往高位补0，则一个数字从左往右第$i$位数就可以作为第$i$关键字；对于字符串，从左往右第$i$个字符就是第$i$关键字。 3、MSD基数排序： （1）从第$1$关键字到第$k$关键字顺序进行比较 （2）需要借助一种稳定算法完成内层对关键字的排序，通常用计数排序来完成 4、LSD基数排序： （1）从第$k$关键字到第$1$关键字顺序比较 （2）同样借助计数排序 5、稳定性：都是稳定的排序算法 6、时间复杂度：比基于比较的排序算法（比如快速排序）更快，但需要额外的内存空间，时间复杂度为$O(kn+\\sum\\limits_{i=1}^k w_i)$ 7、空间复杂度：MSD与LSD基数排序的空间复杂度均为$O(k+n)$ 快速排序 1、原理：通过分治的方法来将一个数组排序,以下为三个过程 将数列划分为两部分(保证相对大小关系) 递归到两个子序列中分别进行快速排序 不用合并,因为此时数列已经完全有序 2、和归并排序的区别：在分成前后两份的时候，会保证前数组最大比后数组最小的值更小，即有相对大小关系，一般随机取一个数来当作两个子数列的分界。 3、步骤：维护前后两个指针p和q，一次考虑当前的数是否放在了应该放的位置（前还是后）。如果当前的数没放对，就交换两个指针所指元素，直到两指针相遇。 4、稳定性：快速排序是一种不稳定的排序算法 5、时间复杂度：最优和平均时间复杂度是$O(n\\log n)$，最欢时间复杂度是$O(n^2)$ 6、示例代码： 12345678910111213141516171819void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j), quick_sort(q, j + 1, r);&#125; 归并排序 1、定义：归并排序是高效的基于比较的稳定排序算法 2、性质；归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优与平均情况下均为$\\Theta (n \\log n)$，空间复杂度为$\\Theta (n) $. 3、过程：将$a[i]$和$b[j]$合并为一个有序的数组$c[k]$，从左往右枚举$a[i]$和$b[j]$，找出最小的值放入c[k]；重复上述过程直到$a[j]$和$b[j]$有一个为空，将另一个数组剩下的元素放入$c[k]$。为保证排序的稳定性，判断条件是$a[i]&lt;=b[j]$而不是$a[i]&lt;b[j]$ 4、示例代码： 123456789101112131415161718192021222324void merge_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j++]; for (i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];&#125; 堆排序 1、定义：利用二叉堆这种数据结构来进行排序，本质是完全二叉树 2、过程：首先建立小根堆，根节点即最小值，取出最小值后，根节点与最后一个结点交换，即减少一个元素，之后再取根结点作为第二小元素，依次循环 3、稳定性：同选择排序一样，由于其中交换位置的操作，所以是不稳定的排序算法 4、时间复杂度：均为$O(nlogn)$ 5、空间复杂度：由于可以在输入数组上建立堆，所以这是一个原地算法 6、代码示例：（acwing 838堆排序） 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int h[N], siz;void down(int u)&#123; int t = u; // 存储三个结点中存在的最小的结点的下标 if (u * 2 &lt;= siz &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= siz &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) &#123; swap(h[u], h[t]); down(t); // 交换数值后，继续下沉 &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;h[i]); siz = n; for (int i = n / 2; i &gt;= 0; i--) // 从一半开始下沉，时间复杂度减小为O(n) &#123; down(i); &#125; while (m--) &#123; printf(&quot;%d &quot;, h[1]); // 输出最小值 h[1] = h[siz]; // 删除最小值，将其替换为最后一个值 siz--; down(1); &#125; return 0;&#125; 桶排序 1、定义：桶排序适用于给定区间，数据值域较大但分布比较均匀的情况 2、过程： 将区间分为n个等分的空桶，确定每个区间大小 遍历序列，并将元素一个个放入对应的桶中（按照大小加入有序的对应区间） 对每个不是空的桶进行排序 从不是空的桶里把元素再放回原来的序列中 3、稳定性：如果使用稳定的内层排序，并且将元素插入桶中时不改变元素间的相对顺序，那么就是一种稳定的排序算法。 4、平均时间复杂度：$O(n)$，最坏时间复杂度为$O(n^2)$ 5、代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 巧妙之处在于将数据插入到区间时就已经整体有序了，接着区间内排序再插回数组就可以了#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int n, w, a[N]; // w为最大值，n为元素个数vector&lt;int&gt; bucket[N];void insertion_sort(vector&lt;int&gt; &amp;A) // 插入排序在小区间性能优秀&#123; // 此时A是bucket[i]对应的数组 for (int i = 1; i &lt; A.size(); ++i) &#123; int key = A[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; A[j] &gt; key) &#123; A[j + 1] = A[j]; --j; &#125; A[j + 1] = key; &#125;&#125;void bucket_sort()&#123; int bucket_size = w / n + 1; // 确定每个桶区间大小 for (int i = 0; i &lt; n; ++i) &#123; bucket[i].clear(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; bucket[a[i] / bucket_size].push_back(a[i]); // 将数加入对应区间 &#125; int p = 0; for (int i = 0; i &lt; n; ++i) &#123; insertion_sort(bucket[i]); // 对区间排序 for (int j = 0; j &lt; bucket[i].size(); ++j) &#123; a[++p] = bucket[i][j]; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;w); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; bucket_sort(); for (int i = 1; i &lt;= n; i++) &#123; if (i != 1) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; a[i]; &#125; system(&quot;pause&quot;); return 0;&#125;/*10 102 3 1 8 5 10 4 3 9 6*/ 希尔排序 1、定义：希尔排序也成为缩小增量排序法，是插入排序的一种改进版本，希尔排序以它的发明者希尔命名 2、过程： 将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同） 将这些子序列进行插入排序 减小每个子序列中元素之间的间距（缩小增量），重复上述过程直至间距减少为1 3、时间复杂度：最优时间复杂度为$O(n)$，平均时间复杂度和最坏时间复杂度与间距序列的选取（就是间距如何减小到 1）有关，比如「间距每次除以 3」的希尔排序的时间复杂度是$O(n^{3/2})$。已知最好的最坏时间复杂度为$O(n \\log^2n)$。 4、空间复杂度：希尔排序的空间复杂度为$O(1)$ 5、代码示例： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;void shell_sort(int array[], int length)&#123; int h = 1; while (h &lt; length / 3) &#123; h = 3 * h + 1; // h为1,4,13 &#125; while (h &gt;= 1) // 最后h等于1的时候再进行一个插入排序就ok了 &#123; for (int i = h; i &lt; length; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j = j - h) &#123; // 插入排序是单向和相邻的比较 swap(array[j], array[j - h]); &#125; &#125; h = h / 3; &#125;&#125;int main()&#123; int a[] = &#123;2, 3, 5, 4, 1&#125;, n = 5; shell_sort(a, n); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; system(&quot;pause&quot;); return 0;&#125; 参考： https://oi.wiki/ https://www.acwing.com","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"回文数","slug":"回文数","date":"2023-03-22T09:46:13.000Z","updated":"2023-03-24T14:06:34.665Z","comments":true,"path":"2023/03/22/回文数/","link":"","permalink":"http://example.com/2023/03/22/%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"[NOIP1999 普及组] 回文数 题目描述 若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。 例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。 又如：对于十进制数 $87$： STEP1：$87+78=165$ STEP2：$165+561=726$ STEP3：$726+627=1353$ STEP4：$1353+3531=4884$ 在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。 写一个程序，给定一个 $N$（$2 \\le N \\le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 Impossible!。 输入格式 两行，分别是 $N$，$M$。 输出格式 如果能在 $30$ 步以内得到回文数，输出格式形如 STEP=ans，其中 $\\text{ans}$ 为最少得到回文数的步数。 否则输出 Impossible!。 样例 #1 样例输入 #1 121087 样例输出 #1 1STEP=4 题解 本题用到了高精度加，需要注意的是不需要转换进制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;int n, q[N], l, w[N], ans;string s;void init() // 得到每位的十进制&#123; int j = 0; for (int i = s.length() - 1; i &gt;= 0; i--) &#123; if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) &#123; j++; // 数组q第一位有效是q[1] q[j] = s[i] - &#x27;0&#x27;; &#125; else &#123; j++; q[j] = s[i] - &#x27;A&#x27; + 10; &#125; &#125;&#125;int judge(int a[]) // 判断是否为回文数&#123; int ln = l; int i = 1, j = l; while (ln--) &#123; if (ln &lt; l / 2) break; if (a[i] != a[j]) &#123; return 0; // 不是回文返回0 &#125; i++; j--; &#125; return 1;&#125;void turn(int a[]) // 翻转数组&#123; int j = 0; for (int i = l; i &gt;= 1; i--) &#123; w[++j] = a[i]; &#125;&#125;void add(int a[], int b[])&#123; for (int i = 1; i &lt;= l; i++) &#123; a[i] = a[i] + b[i]; a[i + 1] = a[i + 1] + a[i] / n; // 进位 a[i] = a[i] % n; // 注意，此处%n和/n表示所有进制通用 &#125; if (a[l + 1] &gt; 0) &#123; // 最高位进位了 l++; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; s; init(); // 把s字符串存入q数组中 l = s.length(); while (!judge(q)) // 不是回文继续循环 &#123; turn(q); add(q, w); ans++; if (ans &gt; 30) break; &#125; if (ans &gt; 30) cout &lt;&lt; &quot;Impossible!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;STEP=&quot; &lt;&lt; ans &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"使用archlinux参考文章","slug":"使用archlinux参考文章","date":"2023-01-08T04:18:22.620Z","updated":"2023-05-02T03:03:50.378Z","comments":true,"path":"2023/01/08/使用archlinux参考文章/","link":"","permalink":"http://example.com/2023/01/08/%E4%BD%BF%E7%94%A8archlinux%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0/","excerpt":"","text":"arch wiki：https://wiki.archlinuxcn.org/wiki/安装指南 安装参考：https://blog.linioi.com/posts/18/ 连网参考： https://blog.csdn.net/bangren3304/article/details/101078641 https://blog.csdn.net/ZHISHAN_IoT/article/details/123453619 字体参考：https://blog.csdn.net/m0_47627464/article/details/113790309 安装manjora参考：https://zhuanlan.zhihu.com/p/462061314 安装下载失败参考：https://blog.csdn.net/weixin_44757863/article/details/120235365 安装软件参考：Arch系下的软件安装配置 - 知乎 (zhihu.com) 安装deb包：首先安装用yay -S debtap安装debtap，然后升级debtap：sudo debtap -u，用sudo debtap xxx.deb解压，license填GPL，然后用sudo pacman -U xxx.tar.xz来安装软件 使用xshell远程连接：先在manjaro启动ssh服务：systemctl start sshd.service，然后将其设置成开机自启systemctl enable sshd.service，现在就可以直接用xsehll通过ip连接，端口是22。会报错reject X11 forwarding request，这时修改/etc/ssh/sshd_config文件，将X11Forwarding no 改成 X11Forwarding yes，然后重启服务systemctl restart sshd.service即可","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"hexo初建站","slug":"hexo初建站","date":"2022-12-29T08:30:48.000Z","updated":"2023-04-09T15:15:34.109Z","comments":true,"path":"2022/12/29/hexo初建站/","link":"","permalink":"http://example.com/2022/12/29/hexo%E5%88%9D%E5%BB%BA%E7%AB%99/","excerpt":"","text":"1.下载安装git与node.js 2.配置nodejs环境(略) 3.连接github ： git config --global user.name &quot;GitHub用户名&quot; git config --global user.email &quot;GitHub邮箱&quot; 4.创建密匙ssh-keygen -t rsa -C &quot;Github邮箱&quot;，在github中添加密匙 5.验证连接ssh -T git@github.com 6.创建username.github.io（username为github用户名） 7.在本地创建hexo文件夹，进入文件夹内，右键git bash here 8.使用npm install将按照package.json安装所需要的组件放在生成的node_modules文件夹中 9.安装hexo： npm install -g hexo-cli hexo init git init hexo g #生成页面 hexo s #本地预览，用loacalhost:4000 npm install hexo-deployer-git --save 修改\\_config.yml文件末尾部分为： 1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: main 注意：main是主分支，以前主分支是master 10.上传hexo： hexo clean hexo d -g hexo new name创建文章 在github.io页面就能显示hexo了 11.绑定域名： 解析域名到github.io的ip地址上 在hexo根目录的source目录下创建CNAME文件，内容为http://域名 重新上传网页 11.域名开启https 在仓库的settings中pages栏目找到Enforce Https勾选 12.个人博客主题配置（略） 13.github+picgo+typora使用图床（用typora没有vscode的报错黄色提醒真好 \\^o^/~）（注意用shift+enter换行同段写字，类似于wordpress） 14.解决数学公式渲染问题，用kramed，完美解决之前的分数线消失、下标上标显示位置不正确、重复出现公式等问题（有个坑地方需要注意，markdown_it_plus一栏name: markdown-it-katex的设置enable: false，否则不能正确显示） 15.pure主题的代码不好看，可以修改一下（注意highlight一栏的hljs: true开启） 参考： https://hexo.io/zh-cn/docs/ github+picgo+typora kramed代替marked 优化pure、修改pure代码和增加复制","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"markdown的基础用法","slug":"markdown的基础用法","date":"2022-12-29T08:27:29.000Z","updated":"2023-04-19T11:35:05.553Z","comments":true,"path":"2022/12/29/markdown的基础用法/","link":"","permalink":"http://example.com/2022/12/29/markdown%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/","excerpt":"","text":"1.标题 使用#后接空格表示标题,一共六级 例如 # 一级标题 ## 二级标题 2.字体 (1)斜体：*123*或者_123_ 效果为 123 (2)粗体：**123**或者__123__ 效果为 123 (3)粗斜体：***123***或者___123___ 效果为 123 (4)删除线：~~123~~效果为123 (5)下划线：&lt;u&gt;123&lt;/u&gt;效果为 123 3.分割线 用三个以上的星号、减号来建立一个分割线，行内不能有其他东西，也可以在型号活减号中插入空格，即***或--- 示例： 4.列表 markdown支持有序列表和无序列表 (1)无序列表用*或+或-在一行的开头，后接空格，示例： 123 (2)有序列表用数字和.在一行的开头，后接空格，示例： 123 5.特殊符号 使用&amp;emsp;来在markdown中创建全角空格 6.区块 区块引用是再段落开头使用&gt;符号，后面紧跟空格符号，既可以引用嵌套，也可以和列表互相嵌套。列表嵌套在引用中用&gt; *，引用嵌套在列表中用*后每一行一个&gt;，例如； 123 7.代码 (1)段落上的一段代码可以用单反引号`包起来，例如：`printf()`，显示为printf()，在markdown文档中用来把演示代码圈起来很方便。 (2)区块代码通常用三个反引号包起来，并指定一种语言显示为： 1123 8.链接 (1)直接用&lt;&gt;将链接地址包起来，例如&lt;https://remsait.com&gt; (2)若需要自定义链接名称，用[连接名称](链接地址)来表示，例如：[我的博客](https://remnantsaint.github.io)，注意用https:// (3)高级链接：用1作为变量：[Goole][1]，最后在结尾加上[1]: http://www.goole.com/ 9.图片 (1)用法：![alt 属性文本](图片地址 &quot;可选标题&quot;)，其中属性文本是替代文字，可选标题可以没有。高级用法和链接一样。 (2)markdown无法指定图片的高度和宽度，可以用普通的&lt;img&gt;标签：&lt;img decoding=&quot;async&quot; src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt; 10.表格 markdown制作表格用|来分隔不同的单元格，使用-分隔表头和其他行，例如： 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 显示为： 表头 表头 单元格 单元格 单元格 单元格 在第二行的---中，使用-:表示居右对齐、使用:-表示居左对齐、使用:-:表示居中对齐 11.数学公式 1.上标$O(n^2)$，效果为$O(n^2)$ 2.下标$O(n_2)$，效果为$O(n_2)$ 3.分数$\\frac&#123;\\text&#123;分子&#125;&#125;&#123;\\ text&#123;分母&#125;&#125;$，效果为$\\frac{\\text{分子}}{\\text{分母}}$ 4.累加$\\sum\\limits_&#123;i=1&#125;^k a_i$，效果为$\\sum\\limits_{i=1}^k a_i$ 5.约等于$\\approx$，效果为$\\approx$ 注意 (1)在使用vscode编辑markdown时，因为用了markdownlint插件导致html标签有黄色波浪线，右键选择命令面板，打开用户设置，输入以下代码： 12345678910111213&quot;markdownlint.config&quot;: &#123; &quot;default&quot;: true, &quot;MD033&quot;: &#123; &quot;allowed_elements&quot;: [ &quot;font&quot;, &quot;li&quot;, &quot;table&quot;, &quot;tr&quot;, &quot;td&quot;, &quot;u&quot; //自己添加html标签 ] &#125;&#125;, (2)我的package.json文件中hexo-renderer-marked渲染器版本是&quot;^6.0.0&quot;，在浏览器中不会把&amp;emsp;变为空格，会显示&amp;emsp;文本样式，通过更改渲染器来解决问题： 123456npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --savenpm i markdown-it-checkboxnpm i markdown-it-imsizenpm i markdown-it-expandable（该解决方法已改变，更改为kramed，具体看hexo初建站文章中数学公式问题） 参考： https://www.runoob.com/markdown/md-tutorial.html https://blog.csdn.net/qq_42951560/article/details/123596899","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]}],"categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"搜索","slug":"搜索","permalink":"http://example.com/categories/%E6%90%9C%E7%B4%A2/"},{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法基础","slug":"算法基础","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"哈希","slug":"哈希","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C/"},{"name":"高精度","slug":"高精度","permalink":"http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]}